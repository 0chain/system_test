{
  "info": {
    "_postman_id": "209941c9-2f6d-44d9-804f-c0470704cb47",
    "name": "API System Tests",
    "description": "The following is a set of API system / regression / user acceptance tests.\n\nTODO:   \nCOLLAB UPDATE   (CURRENTLY BROKEN)    \nAUTH TICKET    \nALLOCATION RESIZE (CURRENTLY BROKEN)   \nALLOCATION DELETION (CURRENTLY BROKEN)   \nALLOCATION FINALIZATION (CURRENTLY BROKEN)   \nTOKEN STAKE/UNSTAKE   (CURRENTLY BROKEN)",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "item": [
    {
      "name": "Regressions setup",
      "item": [
        {
          "name": "1. Connect to the network",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "async function main(){",
                  "const interval = setTimeout(() => {}, 60000);",
                  "console.log(\"Checkng that crypto example api is running. If not running it should be started within 60s of this call....\")",
                  "blsApiHealthcheck()",
                  "clearTimeout(interval)",
                  "",
                  "async function blsApiHealthcheck(){",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "    pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/health\") , function (err, response){",
                  "    resolve()",
                  "});",
                  " }).then(function(finalResult) {",
                  "     return finalResult;",
                  " })",
                  "}",
                  "",
                  "}",
                  "",
                  "main()",
                  "utils.delayTestUntilHttpCodeReceived(pm, 200)"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "     if(pm.response.code != 200) {",
                  "        postman.setNextRequest(null)",
                  "    }",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"miners\", response.miners);",
                  "    pm.globals.set(\"sharders\", response.sharders);",
                  "});",
                  ""
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://{{network}}/dns/network",
              "protocol": "https",
              "host": [
                "{{network}}"
              ],
              "path": [
                "dns",
                "network"
              ]
            },
            "description": "Call 0Dns, get a list of miners/sharders needed for the rest of the test cases"
          },
          "response": []
        },
        {
          "name": "2. Check miner/sharder status",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Valid miner found\", function () {",
                  "    if(pm.variables.get(\"test_case_miner\") == undefined){",
                  "        postman.setNextRequest(null)",
                  "    }",
                  "    pm.expect(pm.variables.get(\"test_case_miner\")).not.eq(undefined);",
                  "});",
                  "",
                  "pm.test(\"Valid sharder found\", function () {",
                  "     if(pm.variables.get(\"test_case_sharder\") == undefined){",
                  "        postman.setNextRequest(null)",
                  "    }",
                  "    pm.expect(pm.variables.get(\"test_case_sharder\")).not.eq(undefined);",
                  "});"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "async function main(){",
                  "const interval = setTimeout(() => {}, 60000);",
                  "",
                  "miners = pm.variables.get(\"miners\")",
                  "for(i = 0; i < miners.length; i ++){",
                  "    miner = miners[i]",
                  "    if(await isServiceUp(miner)){",
                  "        console.log(\"miner [\" + miner + \"] is up.\")",
                  "        pm.globals.set(\"test_case_miner\", miner);",
                  "        break;",
                  "    } else {",
                  "        console.log(\"miner [\" + miner + \"] is NOT up. Trying next miner...\")",
                  "    }",
                  "}",
                  "",
                  "sharders = pm.variables.get(\"sharders\")",
                  "",
                  "for(i = 0; i < sharders.length; i ++){",
                  "    sharder = sharders[i]",
                  "    if(await isServiceUp(sharder)){",
                  "        console.log(\"sharder [\" + sharder + \"] is up.\")",
                  "        pm.globals.set(\"test_case_sharder\", sharder);",
                  "        break;",
                  "    } else {",
                  "        console.log(\"sharder [\" + sharder + \"] is NOT up. Trying next sharder...\")",
                  "    }",
                  "}",
                  "",
                  "clearTimeout(interval)",
                  "",
                  "/*",
                  "Ensures the Example API required for inline functions such as encrypton and BLS is running",
                  "If this call fails or reaches a timeout, the example API server may be overloaded.",
                  "Please try again in a few minutes",
                  "*/",
                  "async function isServiceUp(endpoint){",
                  "    return await new Promise((resolve, reject) => {",
                  "    pm.sendRequest(endpoint + \"/health\" , function (err, response){",
                  "    resolve(response.code)",
                  "});",
                  " }).then(function(code) {",
                  "     console.log(\"response code for \" + endpoint + \" is \" + code)",
                  "   return (code == 200);",
                  " })",
                  "}",
                  "",
                  "",
                  "}",
                  "main();"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "HEAD",
            "header": [],
            "url": {
              "raw": "https://{{network}}/dns/network?m=\"Postman requires this URL to be present in order to run the pre-request script, we don't care about the response\"",
              "protocol": "https",
              "host": [
                "{{network}}"
              ],
              "path": [
                "dns",
                "network"
              ],
              "query": [
                {
                  "key": "m",
                  "value": "\"Postman requires this URL to be present in order to run the pre-request script, we don't care about the response\""
                }
              ]
            },
            "description": "This does not test the network itself, rather sets up subsequent tests.  \nIterate through list of miners/sharders from 0dns, select a pair that are currently returning a 200. These will be used for the remaining tests."
          },
          "response": []
        },
        {
          "name": "3. Generate Mnemonic",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var mnemonic = \"\";",
                  "for(i = 0; i < 24; i++){",
                  "    mnemonic += pm.variables.replaceIn('{{$randomLoremWord}} ');",
                  "}",
                  "mnemonic = mnemonic.trim();",
                  "",
                  "pm.environment.set(\"mnemonic\", mnemonic);",
                  "console.log(\"generated mnemonic is [\" + mnemonic + \"]\")"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Mnemonic generated\", function () {",
                  "    pm.expect(pm.variables.get(\"mnemonic\")).not.eq(undefined);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "HEAD",
            "header": [],
            "url": {
              "raw": "https://{{network}}/dns/network?m=\"Postman requires this URL to be present in order to run the pre-request script, we don't care about the response\"",
              "protocol": "https",
              "host": [
                "{{network}}"
              ],
              "path": [
                "dns",
                "network"
              ],
              "query": [
                {
                  "key": "m",
                  "value": "\"Postman requires this URL to be present in order to run the pre-request script, we don't care about the response\""
                }
              ]
            },
            "description": "This does not test the network itself, rather sets up subsequent tests.  \nGenerates a random 24-word mnemonic to be used for the rest of the tests"
          },
          "response": []
        }
      ]
    },
    {
      "name": "Get Block",
      "item": [
        {
          "name": "1. Get latest magic block",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://{{network}}/dns/magic_block",
              "protocol": "https",
              "host": [
                "{{network}}"
              ],
              "path": [
                "dns",
                "magic_block"
              ]
            }
          },
          "response": []
        },
        {
          "name": "2. Get latest finalized magic block",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/block/get/latest_finalized_magic_block",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "block",
                "get",
                "latest_finalized_magic_block"
              ]
            }
          },
          "response": []
        },
        {
          "name": "3. Get latest finalized magic block summary",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_miner}}/v1/block/get/latest_finalized_magic_block_summary",
              "host": [
                "{{test_case_miner}}"
              ],
              "path": [
                "v1",
                "block",
                "get",
                "latest_finalized_magic_block_summary"
              ]
            }
          },
          "response": []
        },
        {
          "name": "4. Get latest finalized block",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    ",
                  "    var response = JSON.parse(responseBody);",
                  "",
                  "    pm.globals.set(\"block_hash\", response.hash);",
                  "",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/block/get/latest_finalized",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "block",
                "get",
                "latest_finalized"
              ]
            }
          },
          "response": []
        },
        {
          "name": "5. Get block by id",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/block/get?block={{block_hash}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "block",
                "get"
              ],
              "query": [
                {
                  "key": "block",
                  "value": "{{block_hash}}"
                }
              ]
            }
          },
          "response": []
        }
      ]
    },
    {
      "name": "Create Wallet",
      "item": [
        {
          "name": "1. Create/Restore existing wallet",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  "",
                  "pm.test(\"Wallet id matches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.id).to.eql(pm.variables.get(\"wallet_id\"));",
                  "});",
                  "",
                  "pm.test(\"public key matches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.public_key).to.eql(pm.variables.get(\"public_key\"));",
                  "});"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "async function main() {",
                  "    //postman boilerplate",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    var public_key = await getPublicKey(pm.variables.get(\"mnemonic\"), \"0chain-client-split-key\")",
                  "    var publicKeyHexDump = toByteArray(public_key)",
                  "    pm.globals.set(\"public_key\", public_key);",
                  "    pm.globals.set(\"wallet_id\", await sha3256_Of_HexDump(publicKeyHexDump))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "",
                  "main()",
                  "",
                  "async function getPublicKey(mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/publicKey?mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    Gets an 8-bit hex dump of the public key hex string",
                  "*/",
                  "function toByteArray(hexString) {",
                  "    var result = [];",
                  "    for (var i = 0; i < hexString.length; i += 2) {",
                  "        result.push(parseInt(hexString.substr(i, 2), 16));",
                  "    }",
                  "    return result;",
                  "}",
                  "",
                  "/*",
                  "    Ensure your SHA3-256 impl uses is standard, not keccak-256 (which is what CryptoJS uses)",
                  "    Calling a custom API here as the hashify API does not support hex dump byte arrays, but this is widely supported by hashing libraries",
                  "*/",
                  "async function sha3256_Of_HexDump(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sha3256Hash?data=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Accept",
                "value": "application/json",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"id\": \"{{wallet_id}}\",\n    \"version\": \"null\",\n    \"creation_date\": null,\n    \"public_key\": \"{{public_key}}\"\n}"
            },
            "url": {
              "raw": "{{test_case_miner}}/v1/client/put",
              "host": [
                "{{test_case_miner}}"
              ],
              "path": [
                "v1",
                "client",
                "put"
              ]
            },
            "description": "Create new wallet with mnemonic"
          },
          "response": []
        }
      ]
    },
    {
      "name": "Balance (Empty wallet)",
      "item": [
        {
          "name": "1. Get Balance",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Response code is 400\", function () {",
                  "    pm.expect(responseCode.code).to.eql(400);",
                  "});",
                  "",
                  "pm.test(\"Error code matches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.error).to.eql(\"value not present\");",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/client/get/balance?client_id={{wallet_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "client",
                "get",
                "balance"
              ],
              "query": [
                {
                  "key": "client_id",
                  "value": "{{wallet_id}}"
                }
              ]
            },
            "description": "Get balance for empty wallet"
          },
          "response": []
        }
      ],
      "description": "Observations: this should probably return a non 4xx response"
    },
    {
      "name": "Execute Faucet",
      "item": [
        {
          "name": "1. Execute Faucet",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.globals.set(\"execute_faucet_txn_sent\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "",
                  "    pm.globals.set(\"faucet_txn_hash\", response.entity.hash);",
                  "",
                  "    pm.test(\"Wallet id matches expected\", function () {",
                  "        pm.expect(response.entity.client_id).to.eql(pm.variables.get(\"wallet_id\"));",
                  "    });",
                  "",
                  "    pm.test(\"to_client_id matches expected\", function () {",
                  "        pm.expect(response.entity.to_client_id).to.eql(pm.variables.get(\"faucet_smart_contract_address\"));",
                  "    });",
                  "",
                  "    pm.test(\"signature matches expected\", function () {",
                  "     pm.expect(response.entity.signature).to.eql(pm.variables.get(\"signature\"));",
                  "    });",
                  "});    "
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    // timestamp is in the unix epoch (seconds) format",
                  "    pm.globals.set(\"current_timestamp\", Math.round(Date.now() / 1000));",
                  "",
                  "    // postman boilerplate to retrieve the request body, we need data from here for the hash",
                  "    var requestBody = JSON.parse(Property.replaceSubstitutions(pm.request.body.raw, pm.variables.toObject()))",
                  "    var creationDate = requestBody.creation_date",
                  "    var clientId = requestBody.client_id;",
                  "    var toClientId = requestBody.to_client_id;",
                  "    var transactionValue = requestBody.transaction_value;",
                  "",
                  "    var transactionDataHash = await sha3256(requestBody.transaction_data)",
                  "",
                  "    //if hash data is not available, we insert a blank string rather than hashing one less item",
                  "    var overallHashData = (",
                  "        (creationDate == undefined ? \"\" : creationDate) + \":\" +",
                  "        (clientId == undefined ? \"\" : clientId) + \":\" +",
                  "        (toClientId == undefined ? \"\" : toClientId) + \":\" +",
                  "        (transactionValue == undefined ? \"\" : transactionValue) + \":\" +",
                  "        transactionDataHash",
                  "    )",
                  "    var overallHash = await sha3256(overallHashData)",
                  "",
                  "    pm.globals.set(\"hash_of_request_data\", overallHash);",
                  "",
                  "    var mnemonic = pm.variables.get(\"mnemonic\")",
                  "    pm.globals.set(\"signature\", await sign(overallHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json; charset=utf-8",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"hash\": \"{{hash_of_request_data}}\",\n    \"signature\": \"{{signature}}\",\n    \"version\": \"1.0\",\n    \"client_id\": \"{{wallet_id}}\",\n    \"creation_date\": {{current_timestamp}},\n    \"to_client_id\": \"{{faucet_smart_contract_address}}\",\n    \"transaction_data\": \"{\\\"name\\\":\\\"pour\\\",\\\"input\\\":{},\\\"name\\\":null}\",\n    \"transaction_fee\": 0,\n    \"transaction_type\": 1000,\n    \"transaction_value\": 10000000000,\n    \"txn_output_hash\": \"\",\n    \"public_key\": \"{{public_key}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{test_case_miner}}/v1/transaction/put",
              "host": [
                "{{test_case_miner}}"
              ],
              "path": [
                "v1",
                "transaction",
                "put"
              ]
            },
            "description": "Execute faucet so the new wallet has tokens for the remaining tests"
          },
          "response": []
        },
        {
          "name": "2. Confirm Faucet execution",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"execute_faucet_txn_sent\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"faucet_executed\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "if(utils.isFlagSet(\"execute_faucet_txn_sent\")){",
                  "    utils.delayTestUntilHttpCodeReceived(pm, 200)",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/transaction/get/confirmation?hash={{faucet_txn_hash}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "transaction",
                "get",
                "confirmation"
              ],
              "query": [
                {
                  "key": "hash",
                  "value": "{{faucet_txn_hash}}",
                  "description": "The hash of the faucet transaction"
                }
              ]
            }
          },
          "response": []
        }
      ]
    },
    {
      "name": "Balance (Tokens Present)",
      "item": [
        {
          "name": "1. Get Balance",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"faucet_executed\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  "",
                  "utils.test.runConditionally(\"faucet_executed\",\"Balance matches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.balance).to.eql(10000000000);",
                  "});",
                  "",
                  "utils.test.runConditionally(\"faucet_executed\", \"txn matches faucet txn hash\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.txn).to.eql(pm.variables.get(\"faucet_txn_hash\"));",
                  "});",
                  "",
                  "utils.test.runConditionally(\"faucet_executed\", \"Round present\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.round).to.not.equal(null);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/client/get/balance?client_id={{wallet_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "client",
                "get",
                "balance"
              ],
              "query": [
                {
                  "key": "client_id",
                  "value": "{{wallet_id}}"
                }
              ]
            },
            "description": "Get wallet balance post-faucet"
          },
          "response": []
        }
      ]
    },
    {
      "name": "Lock Interest Tokens",
      "item": [
        {
          "name": "1. Lock interest tokens",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"faucet_executed\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"interest_tokens_locked\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "",
                  "    pm.globals.unset(\"current_timestamp\");",
                  "    pm.globals.unset(\"hash_of_request_data\");",
                  "    pm.globals.unset(\"signature\");",
                  "",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"interest_token_lock_txn_id\", response.entity.hash);",
                  "});    "
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    // timestamp is in the unix epoch (seconds) format",
                  "    pm.globals.set(\"current_timestamp\", Math.round(Date.now() / 1000));",
                  "",
                  "    // postman boilerplate to retrieve the request body, we need data from here for the hash",
                  "    var requestBody = JSON.parse(Property.replaceSubstitutions(pm.request.body.raw, pm.variables.toObject()))",
                  "    var creationDate = requestBody.creation_date",
                  "    var clientId = requestBody.client_id;",
                  "    var toClientId = requestBody.to_client_id;",
                  "    var transactionValue = requestBody.transaction_value;",
                  "",
                  "    var transactionDataHash = await sha3256(requestBody.transaction_data)",
                  "",
                  "    //if hash data is not available, we insert a blank string rather than hashing one less item",
                  "    var overallHashData = (",
                  "        (creationDate == undefined ? \"\" : creationDate) + \":\" +",
                  "        (clientId == undefined ? \"\" : clientId) + \":\" +",
                  "        (toClientId == undefined ? \"\" : toClientId) + \":\" +",
                  "        (transactionValue == undefined ? \"\" : transactionValue) + \":\" +",
                  "        transactionDataHash",
                  "    )",
                  "    var overallHash = await sha3256(overallHashData)",
                  "",
                  "    pm.globals.set(\"hash_of_request_data\", overallHash);",
                  "",
                  "    var mnemonic = pm.variables.get(\"mnemonic\")",
                  "    pm.globals.set(\"signature\", await sign(overallHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"hash\": \"{{hash_of_request_data}}\",\n    \"signature\": \"{{signature}}\",\n    \"version\": \"1.0\",\n    \"client_id\": \"{{wallet_id}}\",\n    \"creation_date\": {{current_timestamp}},\n    \"to_client_id\": \"{{interest_smart_contract_address}}\",\n    \"transaction_data\": \"{\\\"name\\\":\\\"lock\\\",\\\"input\\\":{\\\"duration\\\":\\\"0h1m\\\"}}\",\n    \"transaction_fee\": 0,\n    \"transaction_type\": 1000,\n    \"transaction_value\": 1000000000,\n    \"public_key\": \"{{public_key}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{test_case_miner}}/v1/transaction/put",
              "host": [
                "{{test_case_miner}}"
              ],
              "path": [
                "v1",
                "transaction",
                "put"
              ]
            }
          },
          "response": []
        },
        {
          "name": "2. Confirm token lock",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"interest_tokens_locked\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"interest_tokens_locked_confirmed\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "if(utils.isFlagSet(\"interest_tokens_locked\")){",
                  "    utils.delayTestUntilHttpCodeReceived(pm, 200)",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/transaction/get/confirmation?hash={{interest_token_lock_txn_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "transaction",
                "get",
                "confirmation"
              ],
              "query": [
                {
                  "key": "hash",
                  "value": "{{interest_token_lock_txn_id}}",
                  "description": "The read pool that we have requested be created "
                }
              ]
            },
            "description": "Similar to the create allocation and faucet requests, the lock read tokens request must be confirmed by a consensus of sharders before the read pool can be considered created."
          },
          "response": []
        }
      ],
      "description": "observations: min lock period seems to be 2mins",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "type": "text/javascript",
            "exec": [
              ""
            ]
          }
        },
        {
          "listen": "test",
          "script": {
            "type": "text/javascript",
            "exec": [
              ""
            ]
          }
        }
      ]
    },
    {
      "name": "Create Allocation",
      "item": [
        {
          "name": "1. Create storage allocation with 60 min expiry",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    // timestamp is in the unix epoch (seconds) format",
                  "    var now = Math.round(Date.now() / 1000);",
                  "    pm.globals.set(\"current_timestamp\", now);",
                  "    pm.globals.set(\"expire_10_hours_from_now\", now + 36000);",
                  "",
                  "    // postman boilerplate to retrieve the request body, we need data from here for the hash",
                  "    var requestBody = JSON.parse(Property.replaceSubstitutions(pm.request.body.raw, pm.variables.toObject()))",
                  "    var creationDate = requestBody.creation_date",
                  "    var clientId = requestBody.client_id;",
                  "    var toClientId = requestBody.to_client_id;",
                  "    var transactionValue = requestBody.transaction_value;",
                  "",
                  "    var transactionDataHash = await sha3256(requestBody.transaction_data)",
                  "",
                  "    //if hash data is not available, we insert a blank string rather than hashing one less item",
                  "    var overallHashData = (",
                  "        (creationDate == undefined ? \"\" : creationDate) + \":\" +",
                  "        (clientId == undefined ? \"\" : clientId) + \":\" +",
                  "        (toClientId == undefined ? \"\" : toClientId) + \":\" +",
                  "        (transactionValue == undefined ? \"\" : transactionValue) + \":\" +",
                  "        transactionDataHash",
                  "    )",
                  "    var overallHash = await sha3256(overallHashData)",
                  "",
                  "    pm.globals.set(\"hash_of_request_data\", overallHash);",
                  "",
                  "    var mnemonic = pm.variables.get(\"mnemonic\")",
                  "    pm.globals.set(\"signature\", await sign(overallHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"faucet_executed\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"create_allocation_txn_sent\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "",
                  "    pm.globals.unset(\"current_timestamp\");",
                  "    pm.globals.unset(\"hash_of_request_data\");",
                  "    pm.globals.unset(\"current_timestamp\");",
                  "    pm.globals.unset(\"expire_60_mins_from_now\");",
                  "    pm.globals.unset(\"signature\");",
                  "",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"allocation_create_txn_id\", response.entity.hash);",
                  "});    "
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"hash\": \"{{hash_of_request_data}}\",\n    \"signature\": \"{{signature}}\",\n    \"version\": \"1.0\",\n    \"client_id\": \"{{wallet_id}}\",\n    \"creation_date\": {{current_timestamp}},\n    \"to_client_id\": \"{{storage_smart_contract_address}}\",\n    \"transaction_data\": \"{\\\"name\\\":\\\"new_allocation_request\\\",\\\"input\\\":{\\\"data_shards\\\":2,\\\"expiration_date\\\":{{expire_10_hours_from_now}},\\\"owner_id\\\":\\\"{{wallet_id}}\\\",\\\"owner_public_key\\\":\\\"{{public_key}}\\\",\\\"parity_shards\\\":1,\\\"read_price_range\\\":{\\\"min\\\":0,\\\"max\\\":9223372036854775807},\\\"size\\\":2147483648,\\\"write_price_range\\\":{\\\"min\\\":0,\\\"max\\\":9223372036854775807}}}\",\n    \"transaction_fee\": 0,\n    \"transaction_type\": 1000,\n    \"transaction_value\": 1000000000,\n    \"txn_output_hash\": \"\",\n    \"public_key\": \"{{public_key}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{test_case_miner}}/v1/transaction/put",
              "host": [
                "{{test_case_miner}}"
              ],
              "path": [
                "v1",
                "transaction",
                "put"
              ]
            },
            "description": "Create a storage allocation, used in the remaining storage SC tests"
          },
          "response": []
        },
        {
          "name": "2. Confirm allocation creation",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"create_allocation_txn_sent\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"create_allocation_confirmed\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    var txn_output = JSON.parse(response.txn.transaction_output)",
                  "    pm.globals.set(\"allocation_id\", txn_output.id);",
                  "});   ",
                  ""
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "if(utils.isFlagSet(\"create_allocation_txn_sent\")){",
                  "    utils.delayTestUntilHttpCodeReceived(pm, 200)",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/transaction/get/confirmation?hash={{allocation_create_txn_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "transaction",
                "get",
                "confirmation"
              ],
              "query": [
                {
                  "key": "hash",
                  "value": "{{allocation_create_txn_id}}",
                  "description": "The hash of the allocation that we have requested be created "
                }
              ]
            }
          },
          "response": []
        }
      ],
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "type": "text/javascript",
            "exec": [
              ""
            ]
          }
        },
        {
          "listen": "test",
          "script": {
            "type": "text/javascript",
            "exec": [
              ""
            ]
          }
        }
      ]
    },
    {
      "name": "Lock write tokens",
      "item": [
        {
          "name": "1. Lock write tokens",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"create_allocation_confirmed\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"write_tokens_locked\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "",
                  "    pm.globals.unset(\"current_timestamp\");",
                  "    pm.globals.unset(\"hash_of_request_data\");",
                  "    pm.globals.unset(\"signature\");",
                  "",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"write_pool_id\", response.entity.hash);",
                  "});    "
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    // timestamp is in the unix epoch (seconds) format",
                  "    pm.globals.set(\"current_timestamp\", Math.round(Date.now() / 1000));",
                  "",
                  "    // postman boilerplate to retrieve the request body, we need data from here for the hash",
                  "    var requestBody = JSON.parse(Property.replaceSubstitutions(pm.request.body.raw, pm.variables.toObject()))",
                  "    var creationDate = requestBody.creation_date",
                  "    var clientId = requestBody.client_id;",
                  "    var toClientId = requestBody.to_client_id;",
                  "    var transactionValue = requestBody.transaction_value;",
                  "",
                  "    var transactionDataHash = await sha3256(requestBody.transaction_data)",
                  "",
                  "    //if hash data is not available, we insert a blank string rather than hashing one less item",
                  "    var overallHashData = (",
                  "        (creationDate == undefined ? \"\" : creationDate) + \":\" +",
                  "        (clientId == undefined ? \"\" : clientId) + \":\" +",
                  "        (toClientId == undefined ? \"\" : toClientId) + \":\" +",
                  "        (transactionValue == undefined ? \"\" : transactionValue) + \":\" +",
                  "        transactionDataHash",
                  "    )",
                  "    var overallHash = await sha3256(overallHashData)",
                  "",
                  "    pm.globals.set(\"hash_of_request_data\", overallHash);",
                  "",
                  "    var mnemonic = pm.variables.get(\"mnemonic\")",
                  "    pm.globals.set(\"signature\", await sign(overallHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"hash\": \"{{hash_of_request_data}}\",\n    \"signature\": \"{{signature}}\",\n    \"version\": \"1.0\",\n    \"client_id\": \"{{wallet_id}}\",\n    \"creation_date\": {{current_timestamp}},\n    \"to_client_id\": \"{{storage_smart_contract_address}}\",\n    \"transaction_data\": \"{\\\"name\\\":\\\"write_pool_lock\\\",\\\"input\\\":{\\\"duration\\\":120000000000,\\\"allocation_id\\\":\\\"{{allocation_id}}\\\"}}\",\n    \"transaction_fee\": 0,\n    \"transaction_type\": 1000,\n    \"transaction_value\": 1000000000,\n    \"public_key\": \"{{public_key}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{test_case_miner}}/v1/transaction/put",
              "host": [
                "{{test_case_miner}}"
              ],
              "path": [
                "v1",
                "transaction",
                "put"
              ]
            }
          },
          "response": []
        },
        {
          "name": "2. Confirm token lock",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"write_tokens_locked\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"write_tokens_locked_confirmed\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "if(utils.isFlagSet(\"write_tokens_locked\")){",
                  "    utils.delayTestUntilHttpCodeReceived(pm, 200)",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/transaction/get/confirmation?hash={{write_pool_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "transaction",
                "get",
                "confirmation"
              ],
              "query": [
                {
                  "key": "hash",
                  "value": "{{write_pool_id}}",
                  "description": "The read pool that we have requested be created "
                }
              ]
            },
            "description": "Similar to the create allocation and faucet requests, the lock read tokens request must be confirmed by a consensus of sharders before the read pool can be considered created."
          },
          "response": []
        }
      ],
      "description": "observations: min lock period seems to be 2mins",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "type": "text/javascript",
            "exec": [
              ""
            ]
          }
        },
        {
          "listen": "test",
          "script": {
            "type": "text/javascript",
            "exec": [
              ""
            ]
          }
        }
      ]
    },
    {
      "name": "Retrieve Allocation",
      "item": [
        {
          "name": "1. Retrieve all storage allocations",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Response code is 200\", function () {    ",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});   ",
                  "",
                  "utils.test.runConditionally(\"create_allocation_confirmed\", \"Number of allocations matches expected\", function () {    ",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.length).to.eql(1)",
                  "});   ",
                  "",
                  "utils.test.runConditionally(\"create_allocation_confirmed\", \"Allocation id matches expected\", function () {    ",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response[0].id).to.eql(pm.variables.get(\"allocation_id\"))",
                  "});  ",
                  "",
                  ""
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/screst/{{storage_smart_contract_address}}/allocations?client={{wallet_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "screst",
                "{{storage_smart_contract_address}}",
                "allocations"
              ],
              "query": [
                {
                  "key": "client",
                  "value": "{{wallet_id}}"
                }
              ]
            },
            "description": "Retrieve all storage allocations belonging to the wallet. At this point there should be a single allocation present"
          },
          "response": []
        },
        {
          "name": "2. Retrieve single storage allocation",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"create_allocation_confirmed\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"allocation_retrieved\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "",
                  "    // sets the data we need for subsequent requests.",
                  "    pm.globals.set(\"num_data_shards\", response.data_shards);",
                  "    pm.globals.set(\"num_parity_shards\", response.parity_shards);",
                  "",
                  "    for(i =0; i < response.blobbers.length; i ++){",
                  "        pm.globals.set(\"blobber\" + i + \"_url\", response.blobbers[i].url);",
                  "        pm.globals.set(\"blobber\" + i + \"_id\", response.blobbers[i].id);",
                  "    }",
                  "});   ",
                  "",
                  "utils.test.runConditionally(\"create_allocation_confirmed\", \"Allocation id matches expected\", function () {    ",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.id).to.eql(pm.variables.get(\"allocation_id\"))",
                  "});   ",
                  "",
                  "utils.test.runConditionally(\"create_allocation_confirmed\", \"Allocation txn id matches create txn id\", function () {    ",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.tx).to.eql(pm.variables.get(\"allocation_create_txn_id\"))",
                  "});",
                  "",
                  ""
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/screst/{{storage_smart_contract_address}}/allocation?allocation={{allocation_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "screst",
                "{{storage_smart_contract_address}}",
                "allocation"
              ],
              "query": [
                {
                  "key": "allocation",
                  "value": "{{allocation_id}}"
                }
              ]
            },
            "description": "Retrieve the newly created storage allocation. Data from the result of this test will be used  during the upload test cases"
          },
          "response": []
        }
      ]
    },
    {
      "name": "Update Allocation",
      "item": [
        {
          "name": "1. Update storage allocation",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    // timestamp is in the unix epoch (seconds) format",
                  "    var now = Math.round(Date.now() / 1000);",
                  "    pm.globals.set(\"current_timestamp\", now);",
                  "    pm.globals.set(\"expire_60_mins_from_now\", now + 60);",
                  "",
                  "    // postman boilerplate to retrieve the request body, we need data from here for the hash",
                  "    var requestBody = JSON.parse(Property.replaceSubstitutions(pm.request.body.raw, pm.variables.toObject()))",
                  "    var creationDate = requestBody.creation_date",
                  "    var clientId = requestBody.client_id;",
                  "    var toClientId = requestBody.to_client_id;",
                  "    var transactionValue = requestBody.transaction_value;",
                  "",
                  "    var transactionDataHash = await sha3256(requestBody.transaction_data)",
                  "",
                  "    //if hash data is not available, we insert a blank string rather than hashing one less item",
                  "    var overallHashData = (",
                  "        (creationDate == undefined ? \"\" : creationDate) + \":\" +",
                  "        (clientId == undefined ? \"\" : clientId) + \":\" +",
                  "        (toClientId == undefined ? \"\" : toClientId) + \":\" +",
                  "        (transactionValue == undefined ? \"\" : transactionValue) + \":\" +",
                  "        transactionDataHash",
                  "    )",
                  "    var overallHash = await sha3256(overallHashData)",
                  "",
                  "    pm.globals.set(\"hash_of_request_data\", overallHash);",
                  "",
                  "    var mnemonic = pm.variables.get(\"mnemonic\")",
                  "    pm.globals.set(\"signature\", await sign(overallHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"create_allocation_confirmed\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"update_allocation_txn_sent\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"update_allocation_txn_id\", response.entity.hash);",
                  "    ",
                  "    pm.globals.unset(\"hash_of_request_data\");",
                  "    pm.globals.unset(\"signature\");",
                  "    pm.globals.unset(\"current_timestamp\");",
                  "});    "
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"client_id\": \"{{wallet_id}}\",\n    \"creation_date\": {{current_timestamp}},\n    \"hash\": \"{{hash_of_request_data}}\",\n    \"public_key\": \"{{public_key}}\",\n    \"signature\": \"{{signature}}\",\n    \"to_client_id\": \"{{storage_smart_contract_address}}\",\n    \"transaction_data\": \"{\\\"name\\\":\\\"update_allocation_request\\\",\\\"input\\\":{\\\"expiration_date\\\":0,\\\"id\\\":\\\"{{allocation_id}}\\\",\\\"owner_id\\\":\\\"{{wallet_id}}\\\",\\\"size\\\":30, \\\"expiration_date\\\": 0}}\",\n    \"transaction_fee\": 0,\n    \"transaction_type\": 1000,\n    \"transaction_value\": 0,\n    \"txn_output_hash\": \"\",\n    \"version\": \"1.0\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{test_case_miner}}/v1/transaction/put",
              "host": [
                "{{test_case_miner}}"
              ],
              "path": [
                "v1",
                "transaction",
                "put"
              ]
            },
            "description": "Update storage allocation, adding size.  \nNB there is currently a known BUG with updating expiry to be in the future. This test case should be update when the bug is fixed."
          },
          "response": []
        },
        {
          "name": "2. Confirm allocation update",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"update_allocation_txn_sent\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"update_allocation_confirmed\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "});   ",
                  ""
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "if(utils.isFlagSet(\"update_allocation_txn_sent\")){",
                  "    utils.delayTestUntilHttpCodeReceived(pm, 200)",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/transaction/get/confirmation?hash={{update_allocation_txn_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "transaction",
                "get",
                "confirmation"
              ],
              "query": [
                {
                  "key": "hash",
                  "value": "{{update_allocation_txn_id}}"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "3. Retrieve updated allocation",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"update_allocation_confirmed\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"allocation_retrieved\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "",
                  "    pm.globals.set(\"num_data_shards\", response.data_shards);",
                  "    pm.globals.set(\"num_parity_shards\", response.parity_shards);",
                  "",
                  "    for(i =0; i < response.blobbers.length; i ++){",
                  "        pm.globals.set(\"blobber\" + i + \"_url\", response.blobbers[i].url);",
                  "        pm.globals.set(\"blobber\" + i + \"_id\", response.blobbers[i].id);",
                  "    }",
                  "});   ",
                  "",
                  "utils.test.runConditionally(\"update_allocation_confirmed\", \"Allocation id matches expected\", function () {    ",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.id).to.eql(pm.variables.get(\"allocation_id\"))",
                  "});   ",
                  "",
                  "utils.test.runConditionally(\"update_allocation_confirmed\", \"Allocation txn id matches update txn id\", function () {    ",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.tx).to.eql(pm.variables.get(\"update_allocation_txn_id\"))",
                  "    pm.globals.unset(\"update_allocation_txn_id\");",
                  "});   ",
                  "",
                  ""
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/screst/{{storage_smart_contract_address}}/allocation?allocation={{allocation_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "screst",
                "{{storage_smart_contract_address}}",
                "allocation"
              ],
              "query": [
                {
                  "key": "allocation",
                  "value": "{{allocation_id}}"
                }
              ]
            },
            "description": "Ensure the updated allocation is still retrievable using the original id.  \nEnsure the txn field has been updated with the update txn id"
          },
          "response": []
        }
      ],
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "type": "text/javascript",
            "exec": [
              ""
            ]
          }
        },
        {
          "listen": "test",
          "script": {
            "type": "text/javascript",
            "exec": [
              ""
            ]
          }
        }
      ]
    },
    {
      "name": "Lock read tokens",
      "item": [
        {
          "name": "1. Create read pool",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"faucet_executed\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"read_pool_created\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "",
                  "    pm.globals.unset(\"current_timestamp\");",
                  "    pm.globals.unset(\"current_timestamp\");",
                  "    pm.globals.unset(\"hash_of_request_data\");",
                  "    pm.globals.unset(\"signature\");",
                  "",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"read_pool_id\", response.entity.hash);",
                  "});    "
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    // timestamp is in the unix epoch (seconds) format",
                  "    pm.globals.set(\"current_timestamp\", Math.round(Date.now() / 1000));",
                  "",
                  "    // postman boilerplate to retrieve the request body, we need data from here for the hash",
                  "    var requestBody = JSON.parse(Property.replaceSubstitutions(pm.request.body.raw, pm.variables.toObject()))",
                  "    var creationDate = requestBody.creation_date",
                  "    var clientId = requestBody.client_id;",
                  "    var toClientId = requestBody.to_client_id;",
                  "    var transactionValue = requestBody.transaction_value;",
                  "",
                  "    var transactionDataHash = await sha3256(requestBody.transaction_data)",
                  "",
                  "    //if hash data is not available, we insert a blank string rather than hashing one less item",
                  "    var overallHashData = (",
                  "        (creationDate == undefined ? \"\" : creationDate) + \":\" +",
                  "        (clientId == undefined ? \"\" : clientId) + \":\" +",
                  "        (toClientId == undefined ? \"\" : toClientId) + \":\" +",
                  "        (transactionValue == undefined ? \"\" : transactionValue) + \":\" +",
                  "        transactionDataHash",
                  "    )",
                  "    var overallHash = await sha3256(overallHashData)",
                  "",
                  "    pm.globals.set(\"hash_of_request_data\", overallHash);",
                  "",
                  "    var mnemonic = pm.variables.get(\"mnemonic\")",
                  "    pm.globals.set(\"signature\", await sign(overallHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"hash\": \"{{hash_of_request_data}}\",\n    \"signature\": \"{{signature}}\",\n    \"version\": \"1.0\",\n    \"client_id\": \"{{wallet_id}}\",\n    \"creation_date\": {{current_timestamp}},\n    \"to_client_id\": \"{{storage_smart_contract_address}}\",\n    \"transaction_data\":\"{\\\"name\\\":\\\"new_read_pool\\\",\\\"input\\\":null}\",\n    \"transaction_fee\": 0,\n    \"transaction_type\": 1000,\n    \"transaction_value\": 0,\n    \"public_key\": \"{{public_key}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{test_case_miner}}/v1/transaction/put",
              "host": [
                "{{test_case_miner}}"
              ],
              "path": [
                "v1",
                "transaction",
                "put"
              ]
            }
          },
          "response": []
        },
        {
          "name": "2. Confirm read pool created",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"read_pool_created\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"read_pool_creation_confirmed\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  "",
                  ""
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "if(utils.isFlagSet(\"read_pool_created\")){",
                  "    utils.delayTestUntilHttpCodeReceived(pm, 200)",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/transaction/get/confirmation?hash={{read_pool_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "transaction",
                "get",
                "confirmation"
              ],
              "query": [
                {
                  "key": "hash",
                  "value": "{{read_pool_id}}",
                  "description": "The read pool that we have requested be created "
                }
              ]
            },
            "description": "Similar to the create allocation and faucet requests, the lock read tokens request must be confirmed by a consensus of sharders before the read pool can be considered created."
          },
          "response": []
        },
        {
          "name": "3. Lock read tokens (short expiry)",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "var read_pool_creation_confirmed = pm.variables.get(\"read_pool_creation_confirmed\")",
                  "var create_allocation_confirmed = pm.variables.get(\"create_allocation_confirmed\")",
                  "",
                  "utils.test.runConditionally(read_pool_creation_confirmed && create_allocation_confirmed,\"Response code is 200\", function () {",
                  "    pm.globals.set(\"read_tokens_locked\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "",
                  "    pm.globals.unset(\"current_timestamp\");",
                  "    pm.globals.unset(\"hash_of_request_data\");",
                  "    pm.globals.unset(\"signature\");",
                  "",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"lock_tokens_txn_id\", response.entity.hash);",
                  "});    "
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    // timestamp is in the unix epoch (seconds) format",
                  "    pm.globals.set(\"current_timestamp\", Math.round(Date.now() / 1000));",
                  "",
                  "    // postman boilerplate to retrieve the request body, we need data from here for the hash",
                  "    var requestBody = JSON.parse(Property.replaceSubstitutions(pm.request.body.raw, pm.variables.toObject()))",
                  "    var creationDate = requestBody.creation_date",
                  "    var clientId = requestBody.client_id;",
                  "    var toClientId = requestBody.to_client_id;",
                  "    var transactionValue = requestBody.transaction_value;",
                  "",
                  "    var transactionDataHash = await sha3256(requestBody.transaction_data)",
                  "",
                  "    //if hash data is not available, we insert a blank string rather than hashing one less item",
                  "    var overallHashData = (",
                  "        (creationDate == undefined ? \"\" : creationDate) + \":\" +",
                  "        (clientId == undefined ? \"\" : clientId) + \":\" +",
                  "        (toClientId == undefined ? \"\" : toClientId) + \":\" +",
                  "        (transactionValue == undefined ? \"\" : transactionValue) + \":\" +",
                  "        transactionDataHash",
                  "    )",
                  "    var overallHash = await sha3256(overallHashData)",
                  "",
                  "    pm.globals.set(\"hash_of_request_data\", overallHash);",
                  "",
                  "    var mnemonic = pm.variables.get(\"mnemonic\")",
                  "    pm.globals.set(\"signature\", await sign(overallHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"hash\": \"{{hash_of_request_data}}\",\n    \"signature\": \"{{signature}}\",\n    \"version\": \"1.0\",\n    \"client_id\": \"{{wallet_id}}\",\n    \"creation_date\": {{current_timestamp}},\n    \"to_client_id\": \"{{storage_smart_contract_address}}\",\n    \"transaction_data\": \"{ \\\"name\\\": \\\"read_pool_lock\\\", \\\"input\\\": { \\\"duration\\\": 60000000000, \\\"allocation_id\\\": \\\"{{allocation_id}}\\\" } }\",\n    \"transaction_fee\": 0,\n    \"transaction_type\": 1000,\n    \"transaction_value\": 1000000000,\n    \"public_key\": \"{{public_key}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{test_case_miner}}/v1/transaction/put",
              "host": [
                "{{test_case_miner}}"
              ],
              "path": [
                "v1",
                "transaction",
                "put"
              ]
            }
          },
          "response": []
        },
        {
          "name": "4. Confirm token lock (short expiry)",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"read_tokens_locked\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"read_tokens_locked_confirmed\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  ""
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "if(utils.isFlagSet(\"read_tokens_locked\")){",
                  "    utils.delayTestUntilHttpCodeReceived(pm, 200)",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/transaction/get/confirmation?hash={{lock_tokens_txn_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "transaction",
                "get",
                "confirmation"
              ],
              "query": [
                {
                  "key": "hash",
                  "value": "{{lock_tokens_txn_id}}",
                  "description": "The read pool that we have requested be created "
                }
              ]
            },
            "description": "Similar to the create allocation and faucet requests, the lock read tokens request must be confirmed by a consensus of sharders before the read pool can be considered created."
          },
          "response": []
        },
        {
          "name": "5. Lock read tokens",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "var read_pool_creation_confirmed = pm.variables.get(\"read_pool_creation_confirmed\")",
                  "var create_allocation_confirmed = pm.variables.get(\"create_allocation_confirmed\")",
                  "",
                  "utils.test.runConditionally(read_pool_creation_confirmed && create_allocation_confirmed,\"Response code is 200\", function () {",
                  "    pm.globals.set(\"read_tokens_locked\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "",
                  "    pm.globals.unset(\"current_timestamp\");",
                  "    pm.globals.unset(\"hash_of_request_data\");",
                  "    pm.globals.unset(\"signature\");",
                  "",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"lock_tokens_txn_id\", response.entity.hash);",
                  "});    "
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    // timestamp is in the unix epoch (seconds) format",
                  "    pm.globals.set(\"current_timestamp\", Math.round(Date.now() / 1000));",
                  "",
                  "    // postman boilerplate to retrieve the request body, we need data from here for the hash",
                  "    var requestBody = JSON.parse(Property.replaceSubstitutions(pm.request.body.raw, pm.variables.toObject()))",
                  "    var creationDate = requestBody.creation_date",
                  "    var clientId = requestBody.client_id;",
                  "    var toClientId = requestBody.to_client_id;",
                  "    var transactionValue = requestBody.transaction_value;",
                  "",
                  "    var transactionDataHash = await sha3256(requestBody.transaction_data)",
                  "",
                  "    //if hash data is not available, we insert a blank string rather than hashing one less item",
                  "    var overallHashData = (",
                  "        (creationDate == undefined ? \"\" : creationDate) + \":\" +",
                  "        (clientId == undefined ? \"\" : clientId) + \":\" +",
                  "        (toClientId == undefined ? \"\" : toClientId) + \":\" +",
                  "        (transactionValue == undefined ? \"\" : transactionValue) + \":\" +",
                  "        transactionDataHash",
                  "    )",
                  "    var overallHash = await sha3256(overallHashData)",
                  "",
                  "    pm.globals.set(\"hash_of_request_data\", overallHash);",
                  "",
                  "    var mnemonic = pm.variables.get(\"mnemonic\")",
                  "    pm.globals.set(\"signature\", await sign(overallHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"hash\": \"{{hash_of_request_data}}\",\n    \"signature\": \"{{signature}}\",\n    \"version\": \"1.0\",\n    \"client_id\": \"{{wallet_id}}\",\n    \"creation_date\": {{current_timestamp}},\n    \"to_client_id\": \"{{storage_smart_contract_address}}\",\n    \"transaction_data\": \"{ \\\"name\\\": \\\"read_pool_lock\\\", \\\"input\\\": { \\\"duration\\\": 90000000000, \\\"allocation_id\\\": \\\"{{allocation_id}}\\\" } }\",\n    \"transaction_fee\": 0,\n    \"transaction_type\": 1000,\n    \"transaction_value\": 2500000000,\n    \"public_key\": \"{{public_key}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{test_case_miner}}/v1/transaction/put",
              "host": [
                "{{test_case_miner}}"
              ],
              "path": [
                "v1",
                "transaction",
                "put"
              ]
            }
          },
          "response": []
        },
        {
          "name": "6. Confirm token lock",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"read_tokens_locked\", \" Response code is 200\", function () {",
                  "    pm.globals.set(\"read_tokens_locked_confirmed\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  ""
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "if(utils.isFlagSet(\"read_tokens_locked\")){",
                  "    utils.delayTestUntilHttpCodeReceived(pm, 200)",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/transaction/get/confirmation?hash={{lock_tokens_txn_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "transaction",
                "get",
                "confirmation"
              ],
              "query": [
                {
                  "key": "hash",
                  "value": "{{lock_tokens_txn_id}}",
                  "description": "The read pool that we have requested be created "
                }
              ]
            },
            "description": "Similar to the create allocation and faucet requests, the lock read tokens request must be confirmed by a consensus of sharders before the read pool can be considered created."
          },
          "response": []
        }
      ],
      "description": "Observations: min lock period seems to be 1min",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "type": "text/javascript",
            "exec": [
              ""
            ]
          }
        },
        {
          "listen": "test",
          "script": {
            "type": "text/javascript",
            "exec": [
              ""
            ]
          }
        }
      ]
    },
    {
      "name": "Upload a file",
      "item": [
        {
          "name": "1. Process and erasure code file",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "//variable boilerplate required for subsequent requests.",
                  "var local_filePath = pm.request.body.formdata.find(e => e.key == \"file\").src",
                  "pm.globals.set(\"local_filepath\", local_filePath);",
                  "pm.globals.set(\"filename\", local_filePath.split(\"/\").pop());",
                  "pm.globals.set(\"remote_filepath\", \"/dir/{{filename}}\")",
                  "pm.globals.set(\"erasure_coding_example_api\", \"https://example-0chain-crypto.herokuapp.com/erasureCode\")",
                  "",
                  "",
                  "var num_data_shards = pm.variables.get(\"num_data_shards\");",
                  "var num_parity_shards = pm.variables.get(\"num_parity_shards\");",
                  "",
                  "if(num_data_shards == undefined){",
                  "    pm.globals.set(\"num_data_shards\", 2);",
                  "}",
                  "",
                  "if(num_parity_shards == undefined){",
                  "    pm.globals.set(\"num_parity_shards\", 1);",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"allocation_retrieved\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"ec_shards_retrieved\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "",
                  "    // get the file hash and size from the API as well as parity and data shards.",
                  "    // currently hardcoded for 4 shards.",
                  "    pm.globals.set(\"fileHash\", response.sha1Hash);",
                  "    pm.globals.set(\"fileSize\", response.fileSize);",
                  "",
                  "    for(i =0; i < response.ecShards.length; i ++){",
                  "       pm.globals.set(\"ec_shard_\" + i, response.ecShards[i]);",
                  "    }",
                  "",
                  "    pm.globals.set(\"current_blobber_number\", 0)",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "file",
                  "description": "This is not a 0chain api call but is analogous to using your programming language's read file function. Choose the file you wish to upload.",
                  "type": "file",
                  "src": "test_file"
                }
              ]
            },
            "url": {
              "raw": "{{erasure_coding_example_api}}?numDataShards={{num_data_shards}}&numParityShards={{num_parity_shards}}",
              "host": [
                "{{erasure_coding_example_api}}"
              ],
              "query": [
                {
                  "key": "numDataShards",
                  "value": "{{num_data_shards}}"
                },
                {
                  "key": "numParityShards",
                  "value": "{{num_parity_shards}}"
                }
              ]
            },
            "description": "TODO: This call can be removed and the upload values hardcoded"
          },
          "response": []
        },
        {
          "name": "2. Upload EC shard 1 to blobber",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    pm.globals.set(\"blobber_id_matching_current_blobber\", pm.variables.get(\"blobber0_id\"));",
                  "    pm.globals.set(\"connection_id_for_current_blobber\", _.random(100000000, 999999999));",
                  "    pm.globals.set(\"current_ec_shard\", pm.variables.get(\"ec_shard_0\"))",
                  "",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"ec_shards_retrieved\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"blobber0_upload_success\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"uploadResponse\", response);",
                  "});   ",
                  "",
                  "utils.test.runConditionally(\"ec_shards_retrieved\", \"Filename mateches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.filename).to.eql(\"test_file\");",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "protocolProfileBehavior": {
            "disabledSystemHeaders": {}
          },
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "multipart/form-data;boundary=Xform_data_boundary_exampleX",
                "type": "text"
              },
              {
                "key": "Transfer-Encoding",
                "value": "chunked",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{upload-request}}"
            },
            "url": {
              "raw": "{{blobber0_url}}/v1/file/upload/{{allocation_id}}",
              "host": [
                "{{blobber0_url}}"
              ],
              "path": [
                "v1",
                "file",
                "upload",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "3. Get file reference path for EC shard 1",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber0_upload_success\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"blobber0_ref_path_retrieved\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"referencePathResponseForCurrentBlobber\", response);",
                  "});   "
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{blobber0_url}}/v1/file/referencepath/{{allocation_id}}?paths=[\"{{remote_filepath}}\"]",
              "host": [
                "{{blobber0_url}}"
              ],
              "path": [
                "v1",
                "file",
                "referencepath",
                "{{allocation_id}}"
              ],
              "query": [
                {
                  "key": "paths",
                  "value": "[\"{{remote_filepath}}\"]"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "4. Commit Upoad of EC shard 1",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    var timestamp = Math.round(Date.now() / 1000);",
                  "    var allocationId = blankIfUndefined(pm.variables.get(\"allocation_id\"))",
                  "    var blobberId = blankIfUndefined(pm.variables.get(\"blobber_id_matching_current_blobber\"))",
                  "    var walletId = blankIfUndefined(pm.variables.get(\"wallet_id\"))",
                  "    var mnemonics = pm.variables.get(\"mnemonic\")",
                  "",
                  "",
                  "    //Add the current file to the file reference path and re-compute directory hashes.\t",
                  "    //This requires data from the original upload request, the upload response and the file reference path.",
                  "    var blobberReferencePath = pm.variables.get(\"referencePathResponseForCurrentBlobber\")",
                  "    var uploadResponse = pm.variables.get(\"uploadResponse\")",
                  "    var uploadRequest = JSON.parse(Property.replaceSubstitutions(pm.variables.get(\"upload-metadata\"), pm.variables.toObject()))",
                  "    await addFileToReferencePath(blobberReferencePath, uploadResponse, uploadRequest)",
                  "    ",
                  "",
                  "    //calculate the new allocation root hash",
                  "    var hashData = (await hashCurrentFileRoot(blobberReferencePath) + \":\" + timestamp)",
                  "    var newly_calculated_allocation_root = await sha3256(hashData)",
                  "",
                  "    //sign the request",
                  "    var prevAllocationRoot = (blobberReferencePath.latest_write_marker == undefined ? \"\" : blobberReferencePath.latest_write_marker.allocation_root);",
                  "    var fileSize = blankIfUndefined(uploadResponse.size)",
                  "    var signatureHashData = await sha3256([newly_calculated_allocation_root,",
                  "        prevAllocationRoot,",
                  "        allocationId,",
                  "        blobberId,",
                  "        walletId,",
                  "        fileSize,",
                  "        timestamp",
                  "    ].join(\":\"))",
                  "    var signature = await sign(signatureHashData, mnemonics, \"0chain-client-split-key\")",
                  "",
                  "    pm.globals.set(\"newly_calculated_allocation_root\", newly_calculated_allocation_root);",
                  "    pm.globals.set(\"current_timestamp\", timestamp);",
                  "    pm.globals.set(\"prevAllocationRootForCurrentBlobber\", prevAllocationRoot);",
                  "    pm.globals.set(\"signature\", signature)",
                  "    pm.globals.set(\"file_size\", uploadResponse.size)",
                  "",
                  "    clearTimeout(interval)",
                  "",
                  "",
                  "    async function addFileToReferencePath(blobberReferencePath, uploadResult, uploadRequest) {",
                  "",
                  "        var filePath = uploadRequest.filepath.split('/');",
                  "        var index = filePath.indexOf(\"\");",
                  "",
                  "        if (index !== -1) {",
                  "            filePath.splice(index, 1);",
                  "        }",
                  "",
                  "        await addFileToTree(blobberReferencePath, uploadResult, uploadRequest, filePath)",
                  "    }",
                  "",
                  "    async function addFileToTree(blobberReferencePath, uploadResult, uploadRequest, filePath) {",
                  "        if (isFile(filePath)) {",
                  "            await addFile(blobberReferencePath, uploadRequest, uploadResult);",
                  "            blobberReferencePath.meta_data.hash = await hashCurrentFileRoot(blobberReferencePath);",
                  "        } else {",
                  "            dirName = filePath.splice(0, 1)",
                  "            dir = getDir(dirName, blobberReferencePath);",
                  "            await addFileToTree(dir, uploadResult, uploadRequest, filePath);",
                  "            dir.meta_data.hash = await hashCurrentFileRoot(dir);",
                  "        }",
                  "    }",
                  "",
                  "    async function addFile(blobberReferencePath, uploadRequest, uploadResult) {",
                  "        var metaData = {",
                  "            type: \"f\",",
                  "            name: uploadRequest.filename,",
                  "            path: uploadRequest.filepath,",
                  "            size: uploadResult.size,",
                  "            content_hash: uploadResult.content_hash,",
                  "            merkle_root: uploadResult.merkle_root,",
                  "            actual_file_hash: uploadRequest.actual_hash,",
                  "            actual_file_size: uploadRequest.actual_size,",
                  "            hash: undefined,",
                  "            path_hash: undefined",
                  "        }",
                  "",
                  "",
                  "        metaData.hash = await sha3256([allocationId, metaData.type, metaData.name, metaData.path, metaData.size, metaData.content_hash, metaData.merkle_root, metaData.actual_file_size, metaData.actual_file_hash].join(\":\"))",
                  "",
                  "        metaData.path_hash = await sha3256([allocationId, metaData.path].join(\":\"))",
                  "",
                  "        var newFilePath = {",
                  "            meta_data: metaData",
                  "        }",
                  "",
                  "        if (blobberReferencePath.list == undefined) {",
                  "            blobberReferencePath.list = [];",
                  "        }",
                  "        blobberReferencePath.list.filter(entry => uploadResult.filepath != entry.meta_data.path);",
                  "        blobberReferencePath.list.add(newFilePath);",
                  "    }",
                  "",
                  "    function isFile(path) {",
                  "        return path.length == 1;",
                  "    }",
                  "",
                  "    function getDir(dirName, blobberReferencePath) {",
                  "        if (blobberReferencePath.list == undefined) {",
                  "            blobberReferencePath.list = [];",
                  "        }",
                  "        var existingDir = blobberReferencePath.list.filter(e => dirName == e.meta_data.name && \"d\" == e.meta_data.type);",
                  "",
                  "        if (existingDir == \"\") {",
                  "            var newDir = {",
                  "                list: [],",
                  "                meta_data: {",
                  "                    type: \"d\",",
                  "                    path: blobberReferencePath.meta_data.path.endsWith(\"/\") ? (blobberReferencePath.meta_data.path + dirName) : (blobberReferencePath.meta_data.path + \"/\" + dirName)",
                  "                }",
                  "            }",
                  "            blobberReferencePath.list.add(newDir)",
                  "            return newDir;",
                  "        } else {",
                  "            return existingDir;",
                  "        }",
                  "    }",
                  "",
                  "    async function hashCurrentFileRoot(blobberReferencePath) {",
                  "        if (\"f\" == (blobberReferencePath.meta_data.type) || blobberReferencePath.list == undefined || blobberReferencePath.list.length == 0) {",
                  "            return blobberReferencePath.meta_data.hash;",
                  "        } else {",
                  "            await blobberReferencePath.list.sort(async function(path1, path2) {",
                  "                var path1Hash = await sha3256(allocationId + \":\" + path1.meta_data.path);",
                  "                var path2Hash = await sha3256(allocationId + \":\" + path2.meta_data.path);",
                  "",
                  "                return path1Hash.localeCompare(path2Hash);",
                  "            });",
                  "            ",
                  "            return await sha3256(blobberReferencePath.list.map(ref => ref.meta_data.hash).join(\":\"))",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "function blankIfUndefined(str) {",
                  "    return str == undefined ? \"\" : str;",
                  "}",
                  "",
                  "main()"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber0_ref_path_retrieved\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"blobber0_commit_success\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "protocolProfileBehavior": {
            "disabledSystemHeaders": {
              "connection": true,
              "accept-encoding": true,
              "accept": true,
              "user-agent": true
            }
          },
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "Connection",
                "value": "Keep-Alive",
                "type": "text"
              },
              {
                "key": "Cache-Control",
                "value": "no-cache",
                "type": "text"
              },
              {
                "key": "Transfer-Encoding",
                "value": "chunked",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "connection_id",
                  "value": "{{connection_id_for_current_blobber}}",
                  "description": "The connection you wish to commit",
                  "type": "text"
                },
                {
                  "key": "write_marker",
                  "value": "{\n\"allocation_root\" : \"{{newly_calculated_allocation_root}}\",\n\"prev_allocation_root\" : \"{{prevAllocationRootForCurrentBlobber}}\",\n\"allocation_id\" : \"{{allocation_id}}\",\n\"size\" : {{file_size}},\n\"blobber_id\" : \"{{blobber_id_matching_current_blobber}}\",\n\"timestamp\" : {{current_timestamp}},\n\"client_id\" : \"{{wallet_id}}\",\n\"signature\" : \"{{signature}}\"\n}",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{blobber0_url}}/v1/connection/commit/{{allocation_id}}",
              "host": [
                "{{blobber0_url}}"
              ],
              "path": [
                "v1",
                "connection",
                "commit",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "5. Upload EC shard 2 to blobber",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "  ",
                  "    pm.globals.set(\"blobber_id_matching_current_blobber\", pm.variables.get(\"blobber1_id\"));",
                  "    pm.globals.set(\"connection_id_for_current_blobber\", _.random(100000000, 999999999));",
                  "    pm.globals.set(\"current_ec_shard\", pm.variables.get(\"ec_shard_1\"))",
                  "",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"ec_shards_retrieved\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"blobber1_upload_success\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"uploadResponse\", response);",
                  "});   ",
                  "",
                  "utils.test.runConditionally(\"ec_shards_retrieved\", \"Filename mateches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.filename).to.eql(\"test_file\");",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "protocolProfileBehavior": {
            "disabledSystemHeaders": {}
          },
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "multipart/form-data;boundary=Xform_data_boundary_exampleX",
                "type": "text"
              },
              {
                "key": "Transfer-Encoding",
                "value": "chunked",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{upload-request}}"
            },
            "url": {
              "raw": "{{blobber1_url}}/v1/file/upload/{{allocation_id}}",
              "host": [
                "{{blobber1_url}}"
              ],
              "path": [
                "v1",
                "file",
                "upload",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "6. Get file reference path for EC shard 2",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber1_upload_success\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"blobber1_ref_path_retrieved\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"referencePathResponseForCurrentBlobber\", response);",
                  "});   "
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{blobber1_url}}/v1/file/referencepath/{{allocation_id}}?paths=[\"{{remote_filepath}}\"]",
              "host": [
                "{{blobber1_url}}"
              ],
              "path": [
                "v1",
                "file",
                "referencepath",
                "{{allocation_id}}"
              ],
              "query": [
                {
                  "key": "paths",
                  "value": "[\"{{remote_filepath}}\"]"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "7. Commit Upoad of EC shard 2",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    var timestamp = Math.round(Date.now() / 1000);",
                  "    var allocationId = blankIfUndefined(pm.variables.get(\"allocation_id\"))",
                  "    var blobberId = blankIfUndefined(pm.variables.get(\"blobber_id_matching_current_blobber\"))",
                  "    var walletId = blankIfUndefined(pm.variables.get(\"wallet_id\"))",
                  "    var mnemonics = pm.variables.get(\"mnemonic\")",
                  "",
                  "",
                  "    //Add the current file to the file reference path and re-compute directory hashes.\t",
                  "    //This requires data from the original upload request, the upload response and the file reference path.",
                  "    var blobberReferencePath = pm.variables.get(\"referencePathResponseForCurrentBlobber\")",
                  "    var uploadResponse = pm.variables.get(\"uploadResponse\")",
                  "    var uploadRequest = JSON.parse(Property.replaceSubstitutions(pm.variables.get(\"upload-metadata\"), pm.variables.toObject()))",
                  "    await addFileToReferencePath(blobberReferencePath, uploadResponse, uploadRequest)",
                  "    ",
                  "",
                  "    //calculate the new allocation root hash",
                  "    var hashData = (await hashCurrentFileRoot(blobberReferencePath) + \":\" + timestamp)",
                  "    var newly_calculated_allocation_root = await sha3256(hashData)",
                  "",
                  "    //sign the request",
                  "    var prevAllocationRoot = (blobberReferencePath.latest_write_marker == undefined ? \"\" : blobberReferencePath.latest_write_marker.allocation_root);",
                  "    var fileSize = blankIfUndefined(uploadResponse.size)",
                  "    var signatureHashData = await sha3256([newly_calculated_allocation_root,",
                  "        prevAllocationRoot,",
                  "        allocationId,",
                  "        blobberId,",
                  "        walletId,",
                  "        fileSize,",
                  "        timestamp",
                  "    ].join(\":\"))",
                  "    var signature = await sign(signatureHashData, mnemonics, \"0chain-client-split-key\")",
                  "",
                  "    pm.globals.set(\"newly_calculated_allocation_root\", newly_calculated_allocation_root);",
                  "    pm.globals.set(\"current_timestamp\", timestamp);",
                  "    pm.globals.set(\"prevAllocationRootForCurrentBlobber\", prevAllocationRoot);",
                  "    pm.globals.set(\"signature\", signature)",
                  "    pm.globals.set(\"file_size\", uploadResponse.size)",
                  "",
                  "    clearTimeout(interval)",
                  "",
                  "",
                  "    async function addFileToReferencePath(blobberReferencePath, uploadResult, uploadRequest) {",
                  "",
                  "        var filePath = uploadRequest.filepath.split('/');",
                  "        var index = filePath.indexOf(\"\");",
                  "",
                  "        if (index !== -1) {",
                  "            filePath.splice(index, 1);",
                  "        }",
                  "",
                  "        await addFileToTree(blobberReferencePath, uploadResult, uploadRequest, filePath)",
                  "    }",
                  "",
                  "    async function addFileToTree(blobberReferencePath, uploadResult, uploadRequest, filePath) {",
                  "        if (isFile(filePath)) {",
                  "            await addFile(blobberReferencePath, uploadRequest, uploadResult);",
                  "            blobberReferencePath.meta_data.hash = await hashCurrentFileRoot(blobberReferencePath);",
                  "        } else {",
                  "            dirName = filePath.splice(0, 1)",
                  "            dir = getDir(dirName, blobberReferencePath);",
                  "            await addFileToTree(dir, uploadResult, uploadRequest, filePath);",
                  "            dir.meta_data.hash = await hashCurrentFileRoot(dir);",
                  "        }",
                  "    }",
                  "",
                  "    async function addFile(blobberReferencePath, uploadRequest, uploadResult) {",
                  "        var metaData = {",
                  "            type: \"f\",",
                  "            name: uploadRequest.filename,",
                  "            path: uploadRequest.filepath,",
                  "            size: uploadResult.size,",
                  "            content_hash: uploadResult.content_hash,",
                  "            merkle_root: uploadResult.merkle_root,",
                  "            actual_file_hash: uploadRequest.actual_hash,",
                  "            actual_file_size: uploadRequest.actual_size,",
                  "            hash: undefined,",
                  "            path_hash: undefined",
                  "        }",
                  "",
                  "",
                  "        metaData.hash = await sha3256([allocationId, metaData.type, metaData.name, metaData.path, metaData.size, metaData.content_hash, metaData.merkle_root, metaData.actual_file_size, metaData.actual_file_hash].join(\":\"))",
                  "",
                  "        metaData.path_hash = await sha3256([allocationId, metaData.path].join(\":\"))",
                  "",
                  "        var newFilePath = {",
                  "            meta_data: metaData",
                  "        }",
                  "",
                  "        if (blobberReferencePath.list == undefined) {",
                  "            blobberReferencePath.list = [];",
                  "        }",
                  "        blobberReferencePath.list.filter(entry => uploadResult.filepath != entry.meta_data.path);",
                  "        blobberReferencePath.list.add(newFilePath);",
                  "    }",
                  "",
                  "    function isFile(path) {",
                  "        return path.length == 1;",
                  "    }",
                  "",
                  "    function getDir(dirName, blobberReferencePath) {",
                  "        if (blobberReferencePath.list == undefined) {",
                  "            blobberReferencePath.list = [];",
                  "        }",
                  "        var existingDir = blobberReferencePath.list.filter(e => dirName == e.meta_data.name && \"d\" == e.meta_data.type);",
                  "",
                  "        if (existingDir == \"\") {",
                  "            var newDir = {",
                  "                list: [],",
                  "                meta_data: {",
                  "                    type: \"d\",",
                  "                    path: blobberReferencePath.meta_data.path.endsWith(\"/\") ? (blobberReferencePath.meta_data.path + dirName) : (blobberReferencePath.meta_data.path + \"/\" + dirName)",
                  "                }",
                  "            }",
                  "            blobberReferencePath.list.add(newDir)",
                  "            return newDir;",
                  "        } else {",
                  "            return existingDir;",
                  "        }",
                  "    }",
                  "",
                  "    async function hashCurrentFileRoot(blobberReferencePath) {",
                  "        if (\"f\" == (blobberReferencePath.meta_data.type) || blobberReferencePath.list == undefined || blobberReferencePath.list.length == 0) {",
                  "            return blobberReferencePath.meta_data.hash;",
                  "        } else {",
                  "            await blobberReferencePath.list.sort(async function(path1, path2) {",
                  "                var path1Hash = await sha3256(allocationId + \":\" + path1.meta_data.path);",
                  "                var path2Hash = await sha3256(allocationId + \":\" + path2.meta_data.path);",
                  "",
                  "                return path1Hash.localeCompare(path2Hash);",
                  "            });",
                  "            ",
                  "            return await sha3256(blobberReferencePath.list.map(ref => ref.meta_data.hash).join(\":\"))",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "function blankIfUndefined(str) {",
                  "    return str == undefined ? \"\" : str;",
                  "}",
                  "",
                  "main()"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber1_ref_path_retrieved\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"blobber1_commit_success\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "protocolProfileBehavior": {
            "disabledSystemHeaders": {
              "connection": true,
              "accept-encoding": true,
              "accept": true,
              "user-agent": true
            }
          },
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "Connection",
                "value": "Keep-Alive",
                "type": "text"
              },
              {
                "key": "Cache-Control",
                "value": "no-cache",
                "type": "text"
              },
              {
                "key": "Transfer-Encoding",
                "value": "chunked",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "connection_id",
                  "value": "{{connection_id_for_current_blobber}}",
                  "description": "The connection you wish to commit",
                  "type": "text"
                },
                {
                  "key": "write_marker",
                  "value": "{\n\"allocation_root\" : \"{{newly_calculated_allocation_root}}\",\n\"prev_allocation_root\" : \"{{prevAllocationRootForCurrentBlobber}}\",\n\"allocation_id\" : \"{{allocation_id}}\",\n\"size\" : {{file_size}},\n\"blobber_id\" : \"{{blobber_id_matching_current_blobber}}\",\n\"timestamp\" : {{current_timestamp}},\n\"client_id\" : \"{{wallet_id}}\",\n\"signature\" : \"{{signature}}\"\n}",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{blobber1_url}}/v1/connection/commit/{{allocation_id}}",
              "host": [
                "{{blobber1_url}}"
              ],
              "path": [
                "v1",
                "connection",
                "commit",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "8. Upload EC shard 3 to blobber",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "",
                  "    pm.globals.set(\"blobber_id_matching_current_blobber\", pm.variables.get(\"blobber2_id\"));",
                  "    pm.globals.set(\"connection_id_for_current_blobber\", _.random(100000000, 999999999));",
                  "    pm.globals.set(\"current_ec_shard\", pm.variables.get(\"ec_shard_2\"))",
                  "",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"ec_shards_retrieved\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"blobber2_upload_success\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"uploadResponse\", response);",
                  "});   ",
                  "",
                  "utils.test.runConditionally(\"ec_shards_retrieved\", \"Filename mateches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.filename).to.eql(\"test_file\");",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "protocolProfileBehavior": {
            "disabledSystemHeaders": {}
          },
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "multipart/form-data;boundary=Xform_data_boundary_exampleX",
                "type": "text"
              },
              {
                "key": "Transfer-Encoding",
                "value": "chunked",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{upload-request}}"
            },
            "url": {
              "raw": "{{blobber2_url}}/v1/file/upload/{{allocation_id}}",
              "host": [
                "{{blobber2_url}}"
              ],
              "path": [
                "v1",
                "file",
                "upload",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "9. Get file reference path for EC shard 3",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber2_upload_success\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"blobber2_ref_path_retrieved\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"referencePathResponseForCurrentBlobber\", response);",
                  "});   "
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{blobber2_url}}/v1/file/referencepath/{{allocation_id}}?paths=[\"{{remote_filepath}}\"]",
              "host": [
                "{{blobber2_url}}"
              ],
              "path": [
                "v1",
                "file",
                "referencepath",
                "{{allocation_id}}"
              ],
              "query": [
                {
                  "key": "paths",
                  "value": "[\"{{remote_filepath}}\"]"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "10. Commit Upoad of EC shard 3",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    var timestamp = Math.round(Date.now() / 1000);",
                  "    var allocationId = blankIfUndefined(pm.variables.get(\"allocation_id\"))",
                  "    var blobberId = blankIfUndefined(pm.variables.get(\"blobber_id_matching_current_blobber\"))",
                  "    var walletId = blankIfUndefined(pm.variables.get(\"wallet_id\"))",
                  "    var mnemonics = pm.variables.get(\"mnemonic\")",
                  "",
                  "",
                  "    //Add the current file to the file reference path and re-compute directory hashes.\t",
                  "    //This requires data from the original upload request, the upload response and the file reference path.",
                  "    var blobberReferencePath = pm.variables.get(\"referencePathResponseForCurrentBlobber\")",
                  "    var uploadResponse = pm.variables.get(\"uploadResponse\")",
                  "    var uploadRequest = JSON.parse(Property.replaceSubstitutions(pm.variables.get(\"upload-metadata\"), pm.variables.toObject()))",
                  "    await addFileToReferencePath(blobberReferencePath, uploadResponse, uploadRequest)",
                  "    ",
                  "",
                  "    //calculate the new allocation root hash",
                  "    var hashData = (await hashCurrentFileRoot(blobberReferencePath) + \":\" + timestamp)",
                  "    var newly_calculated_allocation_root = await sha3256(hashData)",
                  "",
                  "    //sign the request",
                  "    var prevAllocationRoot = (blobberReferencePath.latest_write_marker == undefined ? \"\" : blobberReferencePath.latest_write_marker.allocation_root);",
                  "    var fileSize = blankIfUndefined(uploadResponse.size)",
                  "    var signatureHashData = await sha3256([newly_calculated_allocation_root,",
                  "        prevAllocationRoot,",
                  "        allocationId,",
                  "        blobberId,",
                  "        walletId,",
                  "        fileSize,",
                  "        timestamp",
                  "    ].join(\":\"))",
                  "    var signature = await sign(signatureHashData, mnemonics, \"0chain-client-split-key\")",
                  "",
                  "    pm.globals.set(\"newly_calculated_allocation_root\", newly_calculated_allocation_root);",
                  "    pm.globals.set(\"current_timestamp\", timestamp);",
                  "    pm.globals.set(\"prevAllocationRootForCurrentBlobber\", prevAllocationRoot);",
                  "    pm.globals.set(\"signature\", signature)",
                  "    pm.globals.set(\"file_size\", uploadResponse.size)",
                  "",
                  "    clearTimeout(interval)",
                  "",
                  "",
                  "    async function addFileToReferencePath(blobberReferencePath, uploadResult, uploadRequest) {",
                  "",
                  "        var filePath = uploadRequest.filepath.split('/');",
                  "        var index = filePath.indexOf(\"\");",
                  "",
                  "        if (index !== -1) {",
                  "            filePath.splice(index, 1);",
                  "        }",
                  "",
                  "        await addFileToTree(blobberReferencePath, uploadResult, uploadRequest, filePath)",
                  "    }",
                  "",
                  "    async function addFileToTree(blobberReferencePath, uploadResult, uploadRequest, filePath) {",
                  "        if (isFile(filePath)) {",
                  "            await addFile(blobberReferencePath, uploadRequest, uploadResult);",
                  "            blobberReferencePath.meta_data.hash = await hashCurrentFileRoot(blobberReferencePath);",
                  "        } else {",
                  "            dirName = filePath.splice(0, 1)",
                  "            dir = getDir(dirName, blobberReferencePath);",
                  "            await addFileToTree(dir, uploadResult, uploadRequest, filePath);",
                  "            dir.meta_data.hash = await hashCurrentFileRoot(dir);",
                  "        }",
                  "    }",
                  "",
                  "    async function addFile(blobberReferencePath, uploadRequest, uploadResult) {",
                  "        var metaData = {",
                  "            type: \"f\",",
                  "            name: uploadRequest.filename,",
                  "            path: uploadRequest.filepath,",
                  "            size: uploadResult.size,",
                  "            content_hash: uploadResult.content_hash,",
                  "            merkle_root: uploadResult.merkle_root,",
                  "            actual_file_hash: uploadRequest.actual_hash,",
                  "            actual_file_size: uploadRequest.actual_size,",
                  "            hash: undefined,",
                  "            path_hash: undefined",
                  "        }",
                  "",
                  "",
                  "        metaData.hash = await sha3256([allocationId, metaData.type, metaData.name, metaData.path, metaData.size, metaData.content_hash, metaData.merkle_root, metaData.actual_file_size, metaData.actual_file_hash].join(\":\"))",
                  "",
                  "        metaData.path_hash = await sha3256([allocationId, metaData.path].join(\":\"))",
                  "",
                  "        var newFilePath = {",
                  "            meta_data: metaData",
                  "        }",
                  "",
                  "        if (blobberReferencePath.list == undefined) {",
                  "            blobberReferencePath.list = [];",
                  "        }",
                  "        blobberReferencePath.list.filter(entry => uploadResult.filepath != entry.meta_data.path);",
                  "        blobberReferencePath.list.add(newFilePath);",
                  "    }",
                  "",
                  "    function isFile(path) {",
                  "        return path.length == 1;",
                  "    }",
                  "",
                  "    function getDir(dirName, blobberReferencePath) {",
                  "        if (blobberReferencePath.list == undefined) {",
                  "            blobberReferencePath.list = [];",
                  "        }",
                  "        var existingDir = blobberReferencePath.list.filter(e => dirName == e.meta_data.name && \"d\" == e.meta_data.type);",
                  "",
                  "        if (existingDir == \"\") {",
                  "            var newDir = {",
                  "                list: [],",
                  "                meta_data: {",
                  "                    type: \"d\",",
                  "                    path: blobberReferencePath.meta_data.path.endsWith(\"/\") ? (blobberReferencePath.meta_data.path + dirName) : (blobberReferencePath.meta_data.path + \"/\" + dirName)",
                  "                }",
                  "            }",
                  "            blobberReferencePath.list.add(newDir)",
                  "            return newDir;",
                  "        } else {",
                  "            return existingDir;",
                  "        }",
                  "    }",
                  "",
                  "    async function hashCurrentFileRoot(blobberReferencePath) {",
                  "        if (\"f\" == (blobberReferencePath.meta_data.type) || blobberReferencePath.list == undefined || blobberReferencePath.list.length == 0) {",
                  "            return blobberReferencePath.meta_data.hash;",
                  "        } else {",
                  "            await blobberReferencePath.list.sort(async function(path1, path2) {",
                  "                var path1Hash = await sha3256(allocationId + \":\" + path1.meta_data.path);",
                  "                var path2Hash = await sha3256(allocationId + \":\" + path2.meta_data.path);",
                  "",
                  "                return path1Hash.localeCompare(path2Hash);",
                  "            });",
                  "            ",
                  "            return await sha3256(blobberReferencePath.list.map(ref => ref.meta_data.hash).join(\":\"))",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "function blankIfUndefined(str) {",
                  "    return str == undefined ? \"\" : str;",
                  "}",
                  "",
                  "main()"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber2_ref_path_retrieved\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"blobber2_commit_success\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "protocolProfileBehavior": {
            "disabledSystemHeaders": {
              "connection": true,
              "accept-encoding": true,
              "accept": true,
              "user-agent": true
            }
          },
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "Connection",
                "value": "Keep-Alive",
                "type": "text"
              },
              {
                "key": "Cache-Control",
                "value": "no-cache",
                "type": "text"
              },
              {
                "key": "Transfer-Encoding",
                "value": "chunked",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "connection_id",
                  "value": "{{connection_id_for_current_blobber}}",
                  "description": "The connection you wish to commit",
                  "type": "text"
                },
                {
                  "key": "write_marker",
                  "value": "{\n\"allocation_root\" : \"{{newly_calculated_allocation_root}}\",\n\"prev_allocation_root\" : \"{{prevAllocationRootForCurrentBlobber}}\",\n\"allocation_id\" : \"{{allocation_id}}\",\n\"size\" : {{file_size}},\n\"blobber_id\" : \"{{blobber_id_matching_current_blobber}}\",\n\"timestamp\" : {{current_timestamp}},\n\"client_id\" : \"{{wallet_id}}\",\n\"signature\" : \"{{signature}}\"\n}",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{blobber2_url}}/v1/connection/commit/{{allocation_id}}",
              "host": [
                "{{blobber2_url}}"
              ],
              "path": [
                "v1",
                "connection",
                "commit",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        }
      ],
      "description": "observations: better validation needed on uploadmeta",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "type": "text/javascript",
            "exec": [
              "pm.globals.set(\"upload-operation\", \"upload\")"
            ]
          }
        },
        {
          "listen": "test",
          "script": {
            "type": "text/javascript",
            "exec": [
              ""
            ]
          }
        }
      ]
    },
    {
      "name": "Query Allocation Metadata",
      "item": [
        {
          "name": "1. Get File stats",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File name matches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.name).to.eql(\"test_file\");",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File path matches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    var Property = require('postman-collection').Property;",
                  "    var remote_filepath = Property.replaceSubstitutions(pm.variables.get(\"remote_filepath\"), pm.variables.toObject())",
                  "    pm.expect(response.path).to.eql(remote_filepath);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "multipart/form-data"
              },
              {
                "description": "(Required) Client ID i.e. Wallet ID",
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}"
              },
              {
                "description": "(Required) ",
                "key": "X-App-Client-Key",
                "value": "{{public_key}}"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "path",
                  "value": "{{remote_filepath}}",
                  "description": "(Required) File path",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{blobber0_url}}/v1/file/stats/{{allocation_id}}",
              "host": [
                "{{blobber0_url}}"
              ],
              "path": [
                "v1",
                "file",
                "stats",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "2. Get File Meta",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File name matches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.name).to.eql(\"test_file\");",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File path matches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    var Property = require('postman-collection').Property;",
                  "    var remote_filepath = Property.replaceSubstitutions(pm.variables.get(\"remote_filepath\"), pm.variables.toObject())",
                  "    pm.expect(response.path).to.eql(remote_filepath);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "description": "(Required) Client ID i.e. Wallet ID",
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}"
              },
              {
                "description": "(Required) ",
                "key": "X-App-Client-Key",
                "value": "{{public_key}}"
              },
              {
                "key": "Content-Type",
                "value": "multipart/form-data"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "path",
                  "value": "{{remote_filepath}}",
                  "description": "Hash file path and allocation id",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{blobber0_url}}/v1/file/meta/{{allocation_id}}",
              "host": [
                "{{blobber0_url}}"
              ],
              "path": [
                "v1",
                "file",
                "meta",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "3. List files",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File name matches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.list[0].name).to.eql(\"test_file\");",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File path matches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    var Property = require('postman-collection').Property;",
                  "    var remote_filepath = Property.replaceSubstitutions(pm.variables.get(\"remote_filepath\"), pm.variables.toObject())",
                  "    pm.expect(response.list[0].path).to.eql(remote_filepath);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "description": "(Required) Client ID i.e. Wallet ID",
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}"
              },
              {
                "description": "(Required) public key",
                "key": "X-App-Client-Key",
                "value": "{{public_key}}"
              }
            ],
            "url": {
              "raw": "{{blobber0_url}}/v1/file/list/{{allocation_id}}?path=/dir",
              "host": [
                "{{blobber0_url}}"
              ],
              "path": [
                "v1",
                "file",
                "list",
                "{{allocation_id}}"
              ],
              "query": [
                {
                  "key": "path",
                  "value": "/dir"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "4. Get Object path",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File name matches expected in meta_data\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.meta_data.name).to.eql(\"test_file\");",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File path matches expected in meta_data\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    var remote_filepath = Property.replaceSubstitutions(pm.variables.get(\"remote_filepath\"), pm.variables.toObject())",
                  "    pm.expect(response.meta_data.path).to.eql(remote_filepath);",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File name matches expected in path list\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.path.list[0].list[0].name).to.eql(\"test_file\");",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File path matches expected in path list\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    var remote_filepath = Property.replaceSubstitutions(pm.variables.get(\"remote_filepath\"), pm.variables.toObject())",
                  "    pm.expect(response.path.list[0].list[0].path).to.eql(remote_filepath);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "description": "(Required) Client ID i.e. Wallet ID",
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}"
              },
              {
                "description": "(Required) ",
                "key": "X-App-Client-Key",
                "value": "{{public_key}}"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{blobber0_url}}/v1/file/objectpath/{{allocation_id}}?path={{remote_filepath}}&block_num=1",
              "host": [
                "{{blobber0_url}}"
              ],
              "path": [
                "v1",
                "file",
                "objectpath",
                "{{allocation_id}}"
              ],
              "query": [
                {
                  "key": "path",
                  "value": "{{remote_filepath}}",
                  "description": "(Required) File path"
                },
                {
                  "key": "block_num",
                  "value": "1",
                  "description": "(Required) Block number"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "5. Get Object tree",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File name matches expected in meta_data\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.meta_data.name).to.eql(\"test_file\");",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File path matches expected in meta_data\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    var remote_filepath = Property.replaceSubstitutions(pm.variables.get(\"remote_filepath\"), pm.variables.toObject())",
                  "    pm.expect(response.meta_data.path).to.eql(remote_filepath);",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File name matches expected in Ref\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.Ref.name).to.eql(\"test_file\");",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File path matches expected in Ref\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    var remote_filepath = Property.replaceSubstitutions(pm.variables.get(\"remote_filepath\"), pm.variables.toObject())",
                  "    pm.expect(response.Ref.path).to.eql(remote_filepath);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "description": "(Required) Client ID i.e. Wallet ID",
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}"
              },
              {
                "description": "(Required) ",
                "key": "X-App-Client-Key",
                "value": "{{public_key}}"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{blobber0_url}}/v1/file/objecttree/{{allocation_id}}?path={{remote_filepath}}&block_num=1",
              "host": [
                "{{blobber0_url}}"
              ],
              "path": [
                "v1",
                "file",
                "objecttree",
                "{{allocation_id}}"
              ],
              "query": [
                {
                  "key": "path",
                  "value": "{{remote_filepath}}",
                  "description": "(Required) File path"
                },
                {
                  "key": "block_num",
                  "value": "1",
                  "description": "(Required) Block number"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "6. Get Reference Path",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File name matches '/' in meta_data\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.meta_data.name).to.eql(\"/\");",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File path matches '/'' in meta_data\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.meta_data.path).to.eql(\"/\");",
                  "});",
                  "",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File name matches '/'' in Ref\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.Ref.name).to.eql(\"/\");",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File path matches '/'' in Ref\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.Ref.path).to.eql(\"/\");",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"Dir name matches expected in list\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.list[0].meta_data.name).to.eql(\"dir\");",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"Dir path matches expected in list\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.list[0].meta_data.path).to.eql(\"/dir\");",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File name matches expected in dir list\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.list[0].list[0].meta_data.name).to.eql(\"test_file\");",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File path matches expected in dir list\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    var remote_filepath = Property.replaceSubstitutions(pm.variables.get(\"remote_filepath\"), pm.variables.toObject())",
                  "    pm.expect(response.list[0].list[0].meta_data.path).to.eql(remote_filepath);",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"Dir name matches expected in list meta_data\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.list[0].meta_data.name).to.eql(\"dir\");",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"Dir path matches expected in list meta_data\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    var remote_filepath = Property.replaceSubstitutions(pm.variables.get(\"remote_filepath\"), pm.variables.toObject())",
                  "    pm.expect(response.list[0].meta_data.path).to.eql(\"/dir\");",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File name matches expected in list meta_data\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.list[0].list[0].meta_data.name).to.eql(\"test_file\");",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File path matches expected in list meta_data\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    var remote_filepath = Property.replaceSubstitutions(pm.variables.get(\"remote_filepath\"), pm.variables.toObject())",
                  "    pm.expect(response.list[0].list[0].meta_data.path).to.eql(remote_filepath);",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"Dir name matches expected in list Ref\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.list[0].Ref.name).to.eql(\"dir\");",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"Dir path matches expected in list Ref\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.list[0].Ref.path).to.eql(\"/dir\");",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File name matches expected in list Ref\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.list[0].list[0].Ref.name).to.eql(\"test_file\");",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File path matches expected in list Ref\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    var remote_filepath = Property.replaceSubstitutions(pm.variables.get(\"remote_filepath\"), pm.variables.toObject())",
                  "    pm.expect(response.list[0].list[0].Ref.path).to.eql(remote_filepath);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "description": "(Required) Client ID i.e. Wallet ID",
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}"
              },
              {
                "description": "(Required) ",
                "key": "X-App-Client-Key",
                "value": "{{public_key}}"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{blobber0_url}}/v1/file/referencepath/{{allocation_id}}?path={{remote_filepath}}&block_num=1",
              "host": [
                "{{blobber0_url}}"
              ],
              "path": [
                "v1",
                "file",
                "referencepath",
                "{{allocation_id}}"
              ],
              "query": [
                {
                  "key": "path",
                  "value": "{{remote_filepath}}",
                  "description": "(Required) File path"
                },
                {
                  "key": "block_num",
                  "value": "1"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "7. Get File Refs",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File name matches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.refs[0].name).to.eql(\"test_file\");",
                  "});",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"File path matches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    var Property = require('postman-collection').Property;",
                  "    var remote_filepath = Property.replaceSubstitutions(pm.variables.get(\"remote_filepath\"), pm.variables.toObject())",
                  "    pm.expect(response.refs[0].path).to.eql(remote_filepath);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "description": "(Required) Client ID i.e. Wallet ID",
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}"
              },
              {
                "description": "(Required) ",
                "key": "X-App-Client-Key",
                "value": "{{public_key}}"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{blobber0_url}}/v1/file/refs/{{allocation_id}}?path={{remote_filepath}}&refType=regular",
              "host": [
                "{{blobber0_url}}"
              ],
              "path": [
                "v1",
                "file",
                "refs",
                "{{allocation_id}}"
              ],
              "query": [
                {
                  "key": "path",
                  "value": "{{remote_filepath}}",
                  "description": "(Required) File path"
                },
                {
                  "key": "refType",
                  "value": "regular"
                }
              ]
            }
          },
          "response": []
        }
      ]
    },
    {
      "name": "Storage Smart Contract",
      "item": [
        {
          "name": "Get Blobber",
          "item": [
            {
              "name": "1. Get All Blobbers",
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      "pm.test(\"Response code is 200\", function () {",
                      "    pm.expect(responseCode.code).to.eql(200);",
                      "    var response = JSON.parse(responseBody);",
                      "    var nodes = response.Nodes",
                      "    var nodesLength = nodes.length ",
                      "",
                      "    var randomBlobber = nodes[Math.floor(Math.random() * (nodesLength - 1)) + 1]",
                      "",
                      "    pm.globals.set(\"random_blobber\", randomBlobber);",
                      "    pm.globals.set(\"random_blobber_id\", randomBlobber.id);",
                      "});",
                      "",
                      ""
                    ],
                    "type": "text/javascript"
                  }
                }
              ],
              "request": {
                "method": "GET",
                "header": [],
                "url": {
                  "raw": "{{test_case_sharder}}/v1/screst/{{storage_smart_contract_address}}/getblobbers",
                  "host": [
                    "{{test_case_sharder}}"
                  ],
                  "path": [
                    "v1",
                    "screst",
                    "{{storage_smart_contract_address}}",
                    "getblobbers"
                  ]
                }
              },
              "response": []
            },
            {
              "name": "2. Get Specific blobber",
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      "pm.test(\"Response code is 200\", function () {",
                      "    pm.expect(responseCode.code).to.eql(200);",
                      "});",
                      "",
                      ""
                    ],
                    "type": "text/javascript"
                  }
                }
              ],
              "request": {
                "method": "GET",
                "header": [],
                "url": {
                  "raw": "{{test_case_sharder}}/v1/screst/{{storage_smart_contract_address}}/getBlobber?blobber_id={{random_blobber_id}}",
                  "host": [
                    "{{test_case_sharder}}"
                  ],
                  "path": [
                    "v1",
                    "screst",
                    "{{storage_smart_contract_address}}",
                    "getBlobber"
                  ],
                  "query": [
                    {
                      "key": "blobber_id",
                      "value": "{{random_blobber_id}}"
                    }
                  ]
                }
              },
              "response": []
            }
          ],
          "description": "observations: endpoint casing is not consistent"
        },
        {
          "name": "Get Challenge Pool",
          "item": [
            {
              "name": "1. Get Challenge Pool for Allocation",
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      "utils.test.runConditionally(\"create_allocation_confirmed\", \"Response code is 200\", function () {",
                      "    pm.expect(responseCode.code).to.eql(200);",
                      "});",
                      "",
                      ""
                    ],
                    "type": "text/javascript"
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "exec": [
                      ""
                    ],
                    "type": "text/javascript"
                  }
                }
              ],
              "request": {
                "method": "GET",
                "header": [],
                "url": {
                  "raw": "{{test_case_sharder}}/v1/screst/{{storage_smart_contract_address}}/getChallengePoolStat?allocation_id={{allocation_id}}",
                  "host": [
                    "{{test_case_sharder}}"
                  ],
                  "path": [
                    "v1",
                    "screst",
                    "{{storage_smart_contract_address}}",
                    "getChallengePoolStat"
                  ],
                  "query": [
                    {
                      "key": "allocation_id",
                      "value": "{{allocation_id}}"
                    }
                  ]
                },
                "description": "Observations: Might be a good request to send after allocation has expired/ been finalized (once that functionality is working)"
              },
              "response": []
            }
          ]
        }
      ]
    },
    {
      "name": "Download a file",
      "item": [
        {
          "name": "1. Retrieve storage allocation for download",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"create_allocation_confirmed\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"allocation_retrieved\", responseCode.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"num_data_shards\", response.data_shards);",
                  "    pm.globals.set(\"num_parity_shards\", response.parity_shards);",
                  "",
                  "    for(i =0; i < response.blobbers.length; i ++){",
                  "        pm.globals.set(\"blobber\" + i + \"_url\", response.blobbers[i].url);",
                  "        pm.globals.set(\"blobber\" + i + \"_id\", response.blobbers[i].id);",
                  "    }",
                  "",
                  "    pm.globals.set(\"current_blobber_number\", 0)",
                  "    pm.globals.set(\"downloaded_shards\", \"\")",
                  "});   ",
                  ""
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "pm.globals.unset(\"allocation_retrieved\")"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/screst/{{storage_smart_contract_address}}/allocation?allocation={{allocation_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "screst",
                "{{storage_smart_contract_address}}",
                "allocation"
              ],
              "query": [
                {
                  "key": "allocation",
                  "value": "{{allocation_id}}"
                }
              ]
            },
            "description": "Retrieve the storage allocation detail by performing a GET operation on the smart contract.  \nThe result of this will be important information we need such as the number of data and parity shards as well as the id and url of each blobber in the allocation, which is where our data is downloaded from."
          },
          "response": []
        },
        {
          "name": "2. Get metadata for file",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var current_blobber_number = pm.variables.get(\"current_blobber_number\")",
                  "pm.globals.set(\"current_blobber\", pm.variables.get(\"blobber0_url\"));",
                  "pm.globals.set(\"blobber_id_matching_current_blobber\", pm.variables.get(\"blobber0_id\"));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"blobber0_meta_retrieved\", responseCode.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"path_hash\", response.path_hash)",
                  "    pm.globals.set(\"num_of_blocks_to_download\", response.num_of_blocks)",
                  "});   ",
                  ""
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "path",
                  "value": "{{remote_filepath}}",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{blobber0_url}}/v1/file/meta/{{allocation_id}}",
              "host": [
                "{{blobber0_url}}"
              ],
              "path": [
                "v1",
                "file",
                "meta",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "3. Get latest read marker for first blobber",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber0_meta_retrieved\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"blobber0_read_marker_retrieved\", responseCode.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"latest_read_marker_current_counter\", response.counter)",
                  "});   ",
                  ""
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var current_blobber_number = pm.variables.get(\"current_blobber_number\")",
                  "pm.globals.set(\"current_blobber\", pm.variables.get(\"blobber\" + current_blobber_number + \"_url\"));",
                  "pm.globals.set(\"blobber_id_matching_current_blobber\", pm.variables.get(\"blobber\" + current_blobber_number + \"_id\"));"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/screst/:id/latestreadmarker?client={{wallet_id}}&blobber={{blobber0_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "screst",
                ":id",
                "latestreadmarker"
              ],
              "query": [
                {
                  "key": "client",
                  "value": "{{wallet_id}}"
                },
                {
                  "key": "blobber",
                  "value": "{{blobber0_id}}"
                }
              ],
              "variable": [
                {
                  "key": "id",
                  "value": "6dba10422e368813802877a85039d3985d96760ed844092319743fb3a76712d7",
                  "description": "(Required) The address of smart contract"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "4. Download EC shard from first blobber",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "var blobber0_meta_retrieved = pm.variables.get(\"blobber0_meta_retrieved\")",
                  "var blobber0_read_marker_retrieved = pm.variables.get(\"blobber0_read_marker_retrieved\")",
                  "",
                  "utils.test.runConditionally(blobber0_meta_retrieved && blobber0_read_marker_retrieved, \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  "",
                  "utils.test.runConditionally(blobber0_meta_retrieved && blobber0_read_marker_retrieved, \"Data returned\", function() {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "",
                  "    var fail = false;",
                  "    try{",
                  "        pm.globals.set(\"latest_read_marker_current_counter\", pm.response.json().latest_rm.counter)",
                  "        fail = true;",
                  "    } catch(ignored){}",
                  "",
                  "    if(fail){",
                  "        pm.expect.fail(\"Download failed - latest write marker returned, use it in subsequent calculations\")",
                  "    }",
                  "",
                  "    var current_blobber_number = pm.variables.get(\"current_blobber_number\")",
                  "",
                  "    var downloaded_shards = pm.variables.get(\"downloaded_shards\")",
                  "    downloaded_shards = downloaded_shards == undefined ? \"\" : downloaded_shards",
                  "    downloaded_shards = downloaded_shards.split(\",\")",
                  "    ",
                  "    var index = downloaded_shards.indexOf(\"\");",
                  "    if (index !== -1) {",
                  "        downloaded_shards.splice(index, 1);",
                  "    }",
                  "    downloaded_shards.push(\"\\\"\" + responseBody + \"\\\"\")",
                  "    pm.globals.set(\"downloaded_shards\", downloaded_shards.join(\",\"))",
                  "",
                  "    current_blobber_number++;",
                  "",
                  "    var num_data_shards = pm.variables.get(\"num_data_shards\")",
                  "",
                  "    if(current_blobber_number >= num_data_shards){ ",
                  "        // once the correct number of shards have been downlaoded we have enough to resonstruct the file and do not need to download the remaining parity shards",
                  "        console.log(\"Blobbers have successfully been downloaded from, resetting to bloebber 0\")",
                  "        current_blobber_number = 0",
                  "    }",
                  "    pm.globals.set(\"current_blobber_number\", current_blobber_number)",
                  "});"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    var num_blocks = parseInt(Property.replaceSubstitutions(pm.request.body.formdata.find(e => e.key == \"num_blocks\").value, pm.variables.toObject()))",
                  "    var latest_read_marker_current_counter = pm.variables.get(\"latest_read_marker_current_counter\")",
                  "    latest_read_marker_current_counter = parseInt(latest_read_marker_current_counter == undefined ? \"0\" : latest_read_marker_current_counter)",
                  "",
                  "    var read_marker_counter = latest_read_marker_current_counter + num_blocks",
                  "",
                  "    pm.globals.set(\"read_marker_counter\", read_marker_counter);",
                  "",
                  "    pm.globals.set(\"current_timestamp\", Math.round(Date.now() / 1000));",
                  "    var request_read_marker = JSON.parse(Property.replaceSubstitutions(pm.request.body.formdata.find(e => e.key == \"read_marker\").value, pm.variables.toObject()))",
                  "",
                  "",
                  "    var overallHashData = (",
                  "        (request_read_marker.allocation_id == undefined ? \"\" : request_read_marker.allocation_id) + \":\" +",
                  "        (request_read_marker.blobber_id == undefined ? \"\" : request_read_marker.blobber_id) + \":\" +",
                  "        (request_read_marker.client_id == undefined ? \"\" : request_read_marker.client_id) + \":\" +",
                  "        (request_read_marker.client_public_key == undefined ? \"\" : request_read_marker.client_public_key) + \":\" +",
                  "        (request_read_marker.owner_id == undefined ? \"\" : request_read_marker.owner_id) + \":\" +",
                  "        (request_read_marker.counter == undefined ? \"\" : request_read_marker.counter) + \":\" +",
                  "        (request_read_marker.timestamp == undefined ? \"\" : request_read_marker.timestamp)",
                  "    )",
                  "",
                  "",
                  "    var overallHash = await sha3256(overallHashData)",
                  "    pm.globals.set(\"hash_of_request_data\", overallHash);",
                  "    var mnemonic = pm.variables.get(\"mnemonic\")",
                  "    pm.globals.set(\"signature\", await sign(overallHash, mnemonic, \"0chain-client-split-key\"))",
                  "    clearTimeout(interval)",
                  "",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "path_hash",
                  "value": "{{path_hash}}",
                  "type": "text"
                },
                {
                  "key": "block_num",
                  "value": "1",
                  "type": "text"
                },
                {
                  "key": "num_blocks",
                  "value": "{{num_of_blocks_to_download}}",
                  "type": "text"
                },
                {
                  "key": "read_marker",
                  "value": "{\n    \"client_id\": \"{{wallet_id}}\",\n    \"client_public_key\": \"{{public_key}}\",\n    \"blobber_id\": \"{{blobber0_id}}\",\n    \"allocation_id\": \"{{allocation_id}}\",\n    \"owner_id\": \"{{wallet_id}}\",\n    \"timestamp\": {{current_timestamp}},\n    \"counter\": {{read_marker_counter}},\n    \"signature\": \"{{signature}}\"\n}",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{blobber0_url}}/v1/file/download/{{allocation_id}}",
              "host": [
                "{{blobber0_url}}"
              ],
              "path": [
                "v1",
                "file",
                "download",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "5. Get latest read marker for second blobber",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"allocation_retrieved\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"blobber1_read_marker_retrieved\", responseCode.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"latest_read_marker_current_counter\", response.counter)",
                  "});   ",
                  ""
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var current_blobber_number = pm.variables.get(\"current_blobber_number\")",
                  "pm.globals.set(\"current_blobber\", pm.variables.get(\"blobber\" + current_blobber_number + \"_url\"));",
                  "pm.globals.set(\"blobber_id_matching_current_blobber\", pm.variables.get(\"blobber\" + current_blobber_number + \"_id\"));"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/screst/:id/latestreadmarker?client={{wallet_id}}&blobber={{blobber1_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "screst",
                ":id",
                "latestreadmarker"
              ],
              "query": [
                {
                  "key": "client",
                  "value": "{{wallet_id}}"
                },
                {
                  "key": "blobber",
                  "value": "{{blobber1_id}}"
                }
              ],
              "variable": [
                {
                  "key": "id",
                  "value": "6dba10422e368813802877a85039d3985d96760ed844092319743fb3a76712d7",
                  "description": "(Required) The address of smart contract"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "6. Download EC shard from second blobber",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "var blobber0_meta_retrieved = pm.variables.get(\"blobber0_meta_retrieved\")",
                  "var blobber0_read_marker_retrieved = pm.variables.get(\"blobber0_read_marker_retrieved\")",
                  "",
                  "utils.test.runConditionally(blobber0_meta_retrieved && blobber0_read_marker_retrieved, \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  "",
                  "utils.test.runConditionally(blobber0_meta_retrieved && blobber0_read_marker_retrieved, \"Data returned\", function() {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "",
                  "    var fail = false;",
                  "    try{",
                  "        pm.globals.set(\"latest_read_marker_current_counter\", pm.response.json().latest_rm.counter)",
                  "        fail = true;",
                  "    } catch(ignored){}",
                  "",
                  "    if(fail){",
                  "        pm.expect.fail(\"Download failed - latest write marker returned, use it in subsequent calculations\")",
                  "    }",
                  "",
                  "    var current_blobber_number = pm.variables.get(\"current_blobber_number\")",
                  "",
                  "    var downloaded_shards = pm.variables.get(\"downloaded_shards\")",
                  "    downloaded_shards = downloaded_shards == undefined ? \"\" : downloaded_shards",
                  "    downloaded_shards = downloaded_shards.split(\",\")",
                  "    ",
                  "    var index = downloaded_shards.indexOf(\"\");",
                  "    if (index !== -1) {",
                  "        downloaded_shards.splice(index, 1);",
                  "    }",
                  "    downloaded_shards.push(\"\\\"\" + responseBody + \"\\\"\")",
                  "    pm.globals.set(\"downloaded_shards\", downloaded_shards.join(\",\"))",
                  "",
                  "    current_blobber_number++;",
                  "",
                  "    var num_data_shards = pm.variables.get(\"num_data_shards\")",
                  "",
                  "    if(current_blobber_number >= num_data_shards){ ",
                  "        // once the correct number of shards have been downlaoded we have enough to resonstruct the file and do not need to download the remaining parity shards",
                  "        console.log(\"Blobbers have successfully been downloaded from, resetting to bloebber 0\")",
                  "        current_blobber_number = 0",
                  "    }",
                  "    pm.globals.set(\"current_blobber_number\", current_blobber_number)",
                  "});"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    var num_blocks = parseInt(Property.replaceSubstitutions(pm.request.body.formdata.find(e => e.key == \"num_blocks\").value, pm.variables.toObject()))",
                  "    var latest_read_marker_current_counter = pm.variables.get(\"latest_read_marker_current_counter\")",
                  "    latest_read_marker_current_counter = parseInt(latest_read_marker_current_counter == undefined ? \"0\" : latest_read_marker_current_counter)",
                  "",
                  "    var read_marker_counter = latest_read_marker_current_counter + num_blocks",
                  "",
                  "    pm.globals.set(\"read_marker_counter\", read_marker_counter);",
                  "",
                  "    pm.globals.set(\"current_timestamp\", Math.round(Date.now() / 1000));",
                  "    var request_read_marker = JSON.parse(Property.replaceSubstitutions(pm.request.body.formdata.find(e => e.key == \"read_marker\").value, pm.variables.toObject()))",
                  "",
                  "",
                  "    var overallHashData = (",
                  "        (request_read_marker.allocation_id == undefined ? \"\" : request_read_marker.allocation_id) + \":\" +",
                  "        (request_read_marker.blobber_id == undefined ? \"\" : request_read_marker.blobber_id) + \":\" +",
                  "        (request_read_marker.client_id == undefined ? \"\" : request_read_marker.client_id) + \":\" +",
                  "        (request_read_marker.client_public_key == undefined ? \"\" : request_read_marker.client_public_key) + \":\" +",
                  "        (request_read_marker.owner_id == undefined ? \"\" : request_read_marker.owner_id) + \":\" +",
                  "        (request_read_marker.counter == undefined ? \"\" : request_read_marker.counter) + \":\" +",
                  "        (request_read_marker.timestamp == undefined ? \"\" : request_read_marker.timestamp)",
                  "    )",
                  "",
                  "",
                  "    var overallHash = await sha3256(overallHashData)",
                  "    pm.globals.set(\"hash_of_request_data\", overallHash);",
                  "    var mnemonic = pm.variables.get(\"mnemonic\")",
                  "    pm.globals.set(\"signature\", await sign(overallHash, mnemonic, \"0chain-client-split-key\"))",
                  "    clearTimeout(interval)",
                  "",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "path_hash",
                  "value": "{{path_hash}}",
                  "type": "text"
                },
                {
                  "key": "block_num",
                  "value": "1",
                  "type": "text"
                },
                {
                  "key": "num_blocks",
                  "value": "{{num_of_blocks_to_download}}",
                  "type": "text"
                },
                {
                  "key": "read_marker",
                  "value": "{\n    \"client_id\": \"{{wallet_id}}\",\n    \"client_public_key\": \"{{public_key}}\",\n    \"blobber_id\": \"{{blobber1_id}}\",\n    \"allocation_id\": \"{{allocation_id}}\",\n    \"owner_id\": \"{{wallet_id}}\",\n    \"timestamp\": {{current_timestamp}},\n    \"counter\": {{read_marker_counter}},\n    \"signature\": \"{{signature}}\"\n}",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{blobber1_url}}/v1/file/download/{{allocation_id}}",
              "host": [
                "{{blobber1_url}}"
              ],
              "path": [
                "v1",
                "file",
                "download",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        }
      ],
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "type": "text/javascript",
            "exec": [
              ""
            ]
          }
        },
        {
          "listen": "test",
          "script": {
            "type": "text/javascript",
            "exec": [
              ""
            ]
          }
        }
      ]
    },
    {
      "name": "Share a file",
      "item": [
        {
          "name": "1. Create Collaborator wallet",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  "",
                  "pm.test(\"Wallet id matches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.id).to.eql(pm.variables.get(\"collaborator_wallet_id\"));",
                  "});",
                  "",
                  "pm.test(\"public key matches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.public_key).to.eql(pm.variables.get(\"collaborator_public_key\"));",
                  "});"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "async function main() {",
                  "",
                  "var mnemonic = \"\";",
                  "for(i = 0; i < 24; i++){",
                  "    mnemonic += pm.variables.replaceIn('{{$randomLoremWord}} ');",
                  "}",
                  "mnemonic = mnemonic.trim();",
                  "",
                  "pm.globals.set(\"collaborator_mnemonic\", mnemonic);",
                  "console.log(\"generated mnemonic is [\" + mnemonic + \"]\")",
                  "",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    var public_key = await getPublicKey(pm.variables.get(\"collaborator_mnemonic\"), \"0chain-client-split-key\")",
                  "    var publicKeyHexDump = toByteArray(public_key)",
                  "    pm.globals.set(\"collaborator_public_key\", public_key);",
                  "    pm.globals.set(\"collaborator_wallet_id\", await sha3256_Of_HexDump(publicKeyHexDump))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "",
                  "main()",
                  "",
                  "async function getPublicKey(mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/publicKey?mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    Gets an 8-bit hex dump of the public key hex string",
                  "*/",
                  "function toByteArray(hexString) {",
                  "    var result = [];",
                  "    for (var i = 0; i < hexString.length; i += 2) {",
                  "        result.push(parseInt(hexString.substr(i, 2), 16));",
                  "    }",
                  "    return result;",
                  "}",
                  "",
                  "/*",
                  "    Ensure your SHA3-256 impl uses is standard, not keccak-256 (which is what CryptoJS uses)",
                  "    Calling a custom API here as the hashify API does not support hex dump byte arrays, but this is widely supported by hashing libraries",
                  "*/",
                  "async function sha3256_Of_HexDump(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sha3256Hash?data=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Accept",
                "value": "application/json",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"id\": \"{{collaborator_wallet_id}}\",\n    \"version\": \"null\",\n    \"creation_date\": null,\n    \"public_key\": \"{{collaborator_public_key}}\"\n}"
            },
            "url": {
              "raw": "{{test_case_miner}}/v1/client/put",
              "host": [
                "{{test_case_miner}}"
              ],
              "path": [
                "v1",
                "client",
                "put"
              ]
            },
            "description": "Create collaborator wallet with mnemonic"
          },
          "response": []
        },
        {
          "name": "2. Add a Collaborator",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"collaboarator_added\", responseCode.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});   ",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"Message matches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.msg).to.eql(\"Added collaborator successfully\");",
                  "});  "
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "path",
                  "value": "{{remote_filepath}}",
                  "type": "text"
                },
                {
                  "key": "collab_id",
                  "value": "{{collaborator_wallet_id}}",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{blobber0_url}}/v1/file/collaborator/{{allocation_id}}",
              "host": [
                "{{blobber0_url}}"
              ],
              "path": [
                "v1",
                "file",
                "collaborator",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "3. Get metadata for file",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var current_blobber_number = pm.variables.get(\"current_blobber_number\")",
                  "pm.globals.set(\"current_blobber\", pm.variables.get(\"blobber0_url\"));",
                  "pm.globals.set(\"blobber_id_matching_current_blobber\", pm.variables.get(\"blobber0_id\"));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"collaboarator_added\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"blobber0_meta_retrieved\", responseCode.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"path_hash\", response.path_hash)",
                  "    pm.globals.set(\"num_of_blocks_to_download\", response.num_of_blocks)",
                  "});   ",
                  ""
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "path",
                  "value": "{{remote_filepath}}",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{blobber0_url}}/v1/file/meta/{{allocation_id}}",
              "host": [
                "{{blobber0_url}}"
              ],
              "path": [
                "v1",
                "file",
                "meta",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "4. Get latest read marker",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber0_meta_retrieved\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"blobber0_read_marker_retrieved\", responseCode.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"latest_read_marker_current_counter\", response.counter)",
                  "});   ",
                  ""
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var current_blobber_number = pm.variables.get(\"current_blobber_number\")",
                  "pm.globals.set(\"current_blobber\", pm.variables.get(\"blobber\" + current_blobber_number + \"_url\"));",
                  "pm.globals.set(\"blobber_id_matching_current_blobber\", pm.variables.get(\"blobber\" + current_blobber_number + \"_id\"));"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/screst/:id/latestreadmarker?client={{wallet_id}}&blobber={{blobber0_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "screst",
                ":id",
                "latestreadmarker"
              ],
              "query": [
                {
                  "key": "client",
                  "value": "{{wallet_id}}"
                },
                {
                  "key": "blobber",
                  "value": "{{blobber0_id}}"
                }
              ],
              "variable": [
                {
                  "key": "id",
                  "value": "6dba10422e368813802877a85039d3985d96760ed844092319743fb3a76712d7",
                  "description": "(Required) The address of smart contract"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "5. Download as Collaborator",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "var blobber0_meta_retrieved = pm.variables.get(\"blobber0_meta_retrieved\")",
                  "var blobber0_read_marker_retrieved = pm.variables.get(\"blobber0_read_marker_retrieved\")",
                  "",
                  "utils.test.runConditionally(blobber0_meta_retrieved && blobber0_read_marker_retrieved, \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  "",
                  "utils.test.runConditionally(blobber0_meta_retrieved && blobber0_read_marker_retrieved, \"Data returned\", function() {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "",
                  "    var fail = false;",
                  "    try{",
                  "        pm.globals.set(\"latest_read_marker_current_counter\", pm.response.json().latest_rm.counter)",
                  "        fail = true;",
                  "    } catch(ignored){}",
                  "",
                  "    if(fail){",
                  "        pm.expect.fail(\"Download failed - latest write marker returned, use it in subsequent calculations\")",
                  "    }",
                  "",
                  "",
                  "});"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    var num_blocks = parseInt(Property.replaceSubstitutions(pm.request.body.formdata.find(e => e.key == \"num_blocks\").value, pm.variables.toObject()))",
                  "    var latest_read_marker_current_counter = pm.variables.get(\"latest_read_marker_current_counter\")",
                  "    latest_read_marker_current_counter = parseInt(latest_read_marker_current_counter == undefined ? \"0\" : latest_read_marker_current_counter)",
                  "",
                  "    var read_marker_counter = latest_read_marker_current_counter + num_blocks",
                  "",
                  "    pm.globals.set(\"read_marker_counter\", read_marker_counter);",
                  "",
                  "    pm.globals.set(\"current_timestamp\", Math.round(Date.now() / 1000));",
                  "    var request_read_marker = JSON.parse(Property.replaceSubstitutions(pm.request.body.formdata.find(e => e.key == \"read_marker\").value, pm.variables.toObject()))",
                  "",
                  "",
                  "    var overallHashData = (",
                  "        (request_read_marker.allocation_id == undefined ? \"\" : request_read_marker.allocation_id) + \":\" +",
                  "        (request_read_marker.blobber_id == undefined ? \"\" : request_read_marker.blobber_id) + \":\" +",
                  "        (request_read_marker.client_id == undefined ? \"\" : request_read_marker.client_id) + \":\" +",
                  "        (request_read_marker.client_public_key == undefined ? \"\" : request_read_marker.client_public_key) + \":\" +",
                  "        (request_read_marker.owner_id == undefined ? \"\" : request_read_marker.owner_id) + \":\" +",
                  "        (request_read_marker.counter == undefined ? \"\" : request_read_marker.counter) + \":\" +",
                  "        (request_read_marker.timestamp == undefined ? \"\" : request_read_marker.timestamp)",
                  "    )",
                  "",
                  "",
                  "    var overallHash = await sha3256(overallHashData)",
                  "    pm.globals.set(\"hash_of_request_data\", overallHash);",
                  "    var mnemonic = pm.variables.get(\"mnemonic\")",
                  "    pm.globals.set(\"signature\", await sign(overallHash, mnemonic, \"0chain-client-split-key\"))",
                  "    clearTimeout(interval)",
                  "",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{collaborator_wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "path_hash",
                  "value": "{{path_hash}}",
                  "type": "text"
                },
                {
                  "key": "block_num",
                  "value": "1",
                  "type": "text"
                },
                {
                  "key": "num_blocks",
                  "value": "{{num_of_blocks_to_download}}",
                  "type": "text"
                },
                {
                  "key": "read_marker",
                  "value": "{\n    \"client_id\": \"{{collaborator_wallet_id}}\",\n    \"client_public_key\": \"{{public_key}}\",\n    \"blobber_id\": \"{{blobber0_id}}\",\n    \"allocation_id\": \"{{allocation_id}}\",\n    \"owner_id\": \"{{wallet_id}}\",\n    \"timestamp\": {{current_timestamp}},\n    \"counter\": {{read_marker_counter}},\n    \"signature\": \"{{signature}}\"\n}",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{blobber0_url}}/v1/file/download/{{allocation_id}}",
              "host": [
                "{{blobber0_url}}"
              ],
              "path": [
                "v1",
                "file",
                "download",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "6. Delete Collaborator",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"collaboarator_added\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"collaboarator_deleted\", responseCode.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});   ",
                  "",
                  "utils.test.runConditionally(\"collaboarator_added\", \"Message matches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.msg).to.eql(\"Removed collaborator successfully\");",
                  "});  "
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "DELETE",
            "header": [
              {
                "key": "Content-Type",
                "value": "multipart/form-data"
              },
              {
                "description": "(Required) Client ID i.e. Wallet ID",
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}"
              },
              {
                "description": "(Required) ",
                "key": "X-App-Client-Key",
                "value": "{{public_key}}"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "path_hash",
                  "value": "{{path_hash}}",
                  "description": "undefined",
                  "type": "text"
                },
                {
                  "key": "collab_id",
                  "value": "{{share_wallet_id}}",
                  "description": "undefined",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{blobber0_url}}/v1/file/collaborator/{{allocation_id}}",
              "host": [
                "{{blobber0_url}}"
              ],
              "path": [
                "v1",
                "file",
                "collaborator",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "7. Attempt download after collaborator deleted",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"collaboarator_deleted\", \"Response code is 400\", function () {",
                  "    pm.expect(responseCode.code).to.eql(400);",
                  "});",
                  "",
                  "utils.test.runConditionally(\"collaboarator_deleted\", \"Error matches expected\", function() {",
                  "    pm.expect(responseBody.trim()).to.eql(\"download_file: cannot verify auth ticket: invalid_parameters: Auth ticket required if data read by anyone other than owner.\");",
                  "});"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    var num_blocks = parseInt(Property.replaceSubstitutions(pm.request.body.formdata.find(e => e.key == \"num_blocks\").value, pm.variables.toObject()))",
                  "    var latest_read_marker_current_counter = pm.variables.get(\"latest_read_marker_current_counter\")",
                  "    latest_read_marker_current_counter = parseInt(latest_read_marker_current_counter == undefined ? \"0\" : latest_read_marker_current_counter)",
                  "",
                  "    var read_marker_counter = latest_read_marker_current_counter + num_blocks",
                  "",
                  "    pm.globals.set(\"read_marker_counter\", read_marker_counter);",
                  "",
                  "    pm.globals.set(\"current_timestamp\", Math.round(Date.now() / 1000));",
                  "    var request_read_marker = JSON.parse(Property.replaceSubstitutions(pm.request.body.formdata.find(e => e.key == \"read_marker\").value, pm.variables.toObject()))",
                  "",
                  "",
                  "    var overallHashData = (",
                  "        (request_read_marker.allocation_id == undefined ? \"\" : request_read_marker.allocation_id) + \":\" +",
                  "        (request_read_marker.blobber_id == undefined ? \"\" : request_read_marker.blobber_id) + \":\" +",
                  "        (request_read_marker.client_id == undefined ? \"\" : request_read_marker.client_id) + \":\" +",
                  "        (request_read_marker.client_public_key == undefined ? \"\" : request_read_marker.client_public_key) + \":\" +",
                  "        (request_read_marker.owner_id == undefined ? \"\" : request_read_marker.owner_id) + \":\" +",
                  "        (request_read_marker.counter == undefined ? \"\" : request_read_marker.counter) + \":\" +",
                  "        (request_read_marker.timestamp == undefined ? \"\" : request_read_marker.timestamp)",
                  "    )",
                  "",
                  "",
                  "    var overallHash = await sha3256(overallHashData)",
                  "    pm.globals.set(\"hash_of_request_data\", overallHash);",
                  "    var mnemonic = pm.variables.get(\"mnemonic\")",
                  "    pm.globals.set(\"signature\", await sign(overallHash, mnemonic, \"0chain-client-split-key\"))",
                  "    clearTimeout(interval)",
                  "",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{collaborator_wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "path_hash",
                  "value": "{{path_hash}}",
                  "type": "text"
                },
                {
                  "key": "block_num",
                  "value": "1",
                  "type": "text"
                },
                {
                  "key": "num_blocks",
                  "value": "{{num_of_blocks_to_download}}",
                  "type": "text"
                },
                {
                  "key": "read_marker",
                  "value": "{\n    \"client_id\": \"{{collaborator_wallet_id}}\",\n    \"client_public_key\": \"{{public_key}}\",\n    \"blobber_id\": \"{{blobber0_id}}\",\n    \"allocation_id\": \"{{allocation_id}}\",\n    \"owner_id\": \"{{wallet_id}}\",\n    \"timestamp\": {{current_timestamp}},\n    \"counter\": {{read_marker_counter}},\n    \"signature\": \"{{signature}}\"\n}",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{blobber0_url}}/v1/file/download/{{allocation_id}}",
              "host": [
                "{{blobber0_url}}"
              ],
              "path": [
                "v1",
                "file",
                "download",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        }
      ]
    },
    {
      "name": "Replace a File",
      "item": [
        {
          "name": "1. Update File - Bobber 1",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "  ",
                  "    pm.globals.set(\"blobber_id_matching_current_blobber\", pm.variables.get(\"blobber0_id\"));",
                  "    pm.globals.set(\"connection_id_for_current_blobber\", _.random(100000000, 999999999));",
                  "    pm.globals.set(\"current_ec_shard\", pm.variables.get(\"ec_shard_1\"))",
                  "",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"uploadResponse\", response);",
                  "});   "
                ],
                "type": "text/javascript"
              }
            }
          ],
          "protocolProfileBehavior": {
            "disabledSystemHeaders": {}
          },
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "multipart/form-data;boundary=Xform_data_boundary_exampleX",
                "type": "text"
              },
              {
                "key": "Transfer-Encoding",
                "value": "chunked",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{upload-request}}"
            },
            "url": {
              "raw": "{{blobber0_url}}/v1/file/upload/{{allocation_id}}",
              "host": [
                "{{blobber0_url}}"
              ],
              "path": [
                "v1",
                "file",
                "upload",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "2. Update File - Bobber 2",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "  ",
                  "    pm.globals.set(\"blobber_id_matching_current_blobber\", pm.variables.get(\"blobber1_id\"));",
                  "    pm.globals.set(\"connection_id_for_current_blobber\", _.random(100000000, 999999999));",
                  "    pm.globals.set(\"current_ec_shard\", pm.variables.get(\"ec_shard_1\"))",
                  "",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber1_commit_success\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"uploadResponse\", response);",
                  "});   "
                ],
                "type": "text/javascript"
              }
            }
          ],
          "protocolProfileBehavior": {
            "disabledSystemHeaders": {}
          },
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "multipart/form-data;boundary=Xform_data_boundary_exampleX",
                "type": "text"
              },
              {
                "key": "Transfer-Encoding",
                "value": "chunked",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{upload-request}}"
            },
            "url": {
              "raw": "{{blobber1_url}}/v1/file/upload/{{allocation_id}}",
              "host": [
                "{{blobber1_url}}"
              ],
              "path": [
                "v1",
                "file",
                "upload",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "3. Update File - Bobber 3",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "  ",
                  "    pm.globals.set(\"blobber_id_matching_current_blobber\", pm.variables.get(\"blobber2_id\"));",
                  "    pm.globals.set(\"connection_id_for_current_blobber\", _.random(100000000, 999999999));",
                  "    pm.globals.set(\"current_ec_shard\", pm.variables.get(\"ec_shard_1\"))",
                  "",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber2_commit_success\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"uploadResponse\", response);",
                  "});   "
                ],
                "type": "text/javascript"
              }
            }
          ],
          "protocolProfileBehavior": {
            "disabledSystemHeaders": {}
          },
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "multipart/form-data;boundary=Xform_data_boundary_exampleX",
                "type": "text"
              },
              {
                "key": "Transfer-Encoding",
                "value": "chunked",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{upload-request}}"
            },
            "url": {
              "raw": "{{blobber2_url}}/v1/file/upload/{{allocation_id}}",
              "host": [
                "{{blobber2_url}}"
              ],
              "path": [
                "v1",
                "file",
                "upload",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        }
      ],
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "type": "text/javascript",
            "exec": [
              "pm.globals.set(\"upload-operation\", \"update\")"
            ]
          }
        },
        {
          "listen": "test",
          "script": {
            "type": "text/javascript",
            "exec": [
              ""
            ]
          }
        }
      ]
    },
    {
      "name": "Rename a File",
      "item": [
        {
          "name": "1. Rename file - Blobber 1",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});   ",
                  "",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"New filename mateches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.filename).to.eql(\"/new_name\");",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "multipart/form-data"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "connection_id",
                  "value": "{{blobber0_id}}",
                  "description": "undefined",
                  "type": "text"
                },
                {
                  "key": "path",
                  "value": "{{remote_filepath}}",
                  "description": "undefined",
                  "type": "text"
                },
                {
                  "key": "new_name",
                  "value": "/new_name",
                  "description": "undefined",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{blobber0_url}}/v1/file/rename/{{allocation_id}}",
              "host": [
                "{{blobber0_url}}"
              ],
              "path": [
                "v1",
                "file",
                "rename",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "2. Rename file - Blobber 2",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber1_commit_success\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});   ",
                  "",
                  "",
                  "utils.test.runConditionally(\"blobber1_commit_success\", \"New filename mateches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.filename).to.eql(\"/new_name\");",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "multipart/form-data"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "connection_id",
                  "value": "{{blobber1_id}}",
                  "description": "undefined",
                  "type": "text"
                },
                {
                  "key": "path",
                  "value": "{{remote_filepath}}",
                  "description": "undefined",
                  "type": "text"
                },
                {
                  "key": "new_name",
                  "value": "/new_name",
                  "description": "undefined",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{blobber1_url}}/v1/file/rename/{{allocation_id}}",
              "host": [
                "{{blobber1_url}}"
              ],
              "path": [
                "v1",
                "file",
                "rename",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "3. Rename file - Blobber 3",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber2_commit_success\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});   ",
                  "",
                  "",
                  "utils.test.runConditionally(\"blobber2_commit_success\", \"New filename mateches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.filename).to.eql(\"/new_name\");",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "multipart/form-data"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "connection_id",
                  "value": "{{blobber2_id}}",
                  "description": "undefined",
                  "type": "text"
                },
                {
                  "key": "path",
                  "value": "{{remote_filepath}}",
                  "description": "undefined",
                  "type": "text"
                },
                {
                  "key": "new_name",
                  "value": "/new_name",
                  "description": "undefined",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{blobber2_url}}/v1/file/rename/{{allocation_id}}",
              "host": [
                "{{blobber2_url}}"
              ],
              "path": [
                "v1",
                "file",
                "rename",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        }
      ],
      "description": "observations: occasionally fails with error writing data"
    },
    {
      "name": "Copy a File",
      "item": [
        {
          "name": "1. Copy file - Blobber 1",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});   ",
                  ""
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "multipart/form-data"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "connection_id",
                  "value": "{{blobber0_id}}",
                  "description": "undefined",
                  "type": "text"
                },
                {
                  "key": "path",
                  "value": "{{remote_filepath}}",
                  "description": "undefined",
                  "type": "text"
                },
                {
                  "key": "dest",
                  "value": "/",
                  "description": "undefined",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{blobber0_url}}/v1/file/copy/{{allocation_id}}",
              "host": [
                "{{blobber0_url}}"
              ],
              "path": [
                "v1",
                "file",
                "copy",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "2. Copy file - Blobber 2",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber1_commit_success\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});   ",
                  ""
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "multipart/form-data"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "connection_id",
                  "value": "{{blobber1_id}}",
                  "description": "undefined",
                  "type": "text"
                },
                {
                  "key": "path",
                  "value": "{{remote_filepath}}",
                  "description": "undefined",
                  "type": "text"
                },
                {
                  "key": "dest",
                  "value": "/",
                  "description": "undefined",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{blobber1_url}}/v1/file/copy/{{allocation_id}}",
              "host": [
                "{{blobber1_url}}"
              ],
              "path": [
                "v1",
                "file",
                "copy",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "3. Copy file - Blobber 3",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber2_commit_success\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});   ",
                  ""
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "multipart/form-data"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "connection_id",
                  "value": "{{blobber2_id}}",
                  "description": "undefined",
                  "type": "text"
                },
                {
                  "key": "path",
                  "value": "{{remote_filepath}}",
                  "description": "undefined",
                  "type": "text"
                },
                {
                  "key": "dest",
                  "value": "/",
                  "description": "undefined",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{blobber2_url}}/v1/file/copy/{{allocation_id}}",
              "host": [
                "{{blobber2_url}}"
              ],
              "path": [
                "v1",
                "file",
                "copy",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        }
      ],
      "description": "observations: occasionally fails with error writing data"
    },
    {
      "name": "Delete a File",
      "item": [
        {
          "name": "1. Delete file - Blobber 1",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});   ",
                  "",
                  "utils.test.runConditionally(\"blobber0_commit_success\", \"Filename mateches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.filename).to.eql(\"test_file\");",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "DELETE",
            "header": [
              {
                "key": "Content-Type",
                "value": "multipart/form-data"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "connection_id",
                  "value": "{{blobber0_id}}",
                  "description": "undefined",
                  "type": "text"
                },
                {
                  "key": "path",
                  "value": "{{remote_filepath}}",
                  "description": "undefined",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{blobber0_url}}/v1/file/upload/{{allocation_id}}",
              "host": [
                "{{blobber0_url}}"
              ],
              "path": [
                "v1",
                "file",
                "upload",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "2. Delete file - Blobber 2",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber1_commit_success\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});   ",
                  "",
                  "utils.test.runConditionally(\"blobber1_commit_success\", \"Filename mateches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.filename).to.eql(\"test_file\");",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "DELETE",
            "header": [
              {
                "key": "Content-Type",
                "value": "multipart/form-data"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "connection_id",
                  "value": "{{blobber1_id}}",
                  "description": "undefined",
                  "type": "text"
                },
                {
                  "key": "path",
                  "value": "{{remote_filepath}}",
                  "description": "undefined",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{blobber1_url}}/v1/file/upload/{{allocation_id}}",
              "host": [
                "{{blobber1_url}}"
              ],
              "path": [
                "v1",
                "file",
                "upload",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "3. Delete file - Blobber 3",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"blobber2_commit_success\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});   ",
                  "",
                  "utils.test.runConditionally(\"blobber2_commit_success\", \"Filename mateches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.filename).to.eql(\"test_file\");",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "DELETE",
            "header": [
              {
                "key": "Content-Type",
                "value": "multipart/form-data"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "connection_id",
                  "value": "{{blobber2_id}}",
                  "description": "undefined",
                  "type": "text"
                },
                {
                  "key": "path",
                  "value": "{{remote_filepath}}",
                  "description": "undefined",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{blobber2_url}}/v1/file/upload/{{allocation_id}}",
              "host": [
                "{{blobber2_url}}"
              ],
              "path": [
                "v1",
                "file",
                "upload",
                "{{allocation_id}}"
              ]
            }
          },
          "response": []
        }
      ],
      "description": "observations: occasionally fails with error writing data"
    },
    {
      "name": "Send ZCN",
      "item": [
        {
          "name": "1. Send ZCN",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"faucet_executed\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"zcn_sent\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"send_zcn_txn_id\", response.entity.hash);",
                  "});    "
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    // timestamp is in the unix epoch (seconds) format",
                  "    pm.globals.set(\"current_timestamp\", Math.round(Date.now() / 1000));",
                  "    pm.globals.set(\"to_wallet_id\", \"3150043ba4a7e0092d282c5e88\" + Math.round(Date.now() / 1000) + \"a85d2f8cb8dd4f71881223ba9eb6\");",
                  "    pm.globals.set(\"send_amount\", 1000000000)",
                  "",
                  "    // postman boilerplate to retrieve the request body, we need data from here for the hash",
                  "    var requestBody = JSON.parse(Property.replaceSubstitutions(pm.request.body.raw, pm.variables.toObject()))",
                  "    var creationDate = requestBody.creation_date",
                  "    var clientId = requestBody.client_id;",
                  "    var toClientId = requestBody.to_client_id;",
                  "    var transactionValue = requestBody.transaction_value;",
                  "",
                  "    var transactionDataHash = await sha3256(requestBody.transaction_data)",
                  "",
                  "    //if hash data is not available, we insert a blank string rather than hashing one less item",
                  "    var overallHashData = (",
                  "        (creationDate == undefined ? \"\" : creationDate) + \":\" +",
                  "        (clientId == undefined ? \"\" : clientId) + \":\" +",
                  "        (toClientId == undefined ? \"\" : toClientId) + \":\" +",
                  "        (transactionValue == undefined ? \"\" : transactionValue) + \":\" +",
                  "        transactionDataHash",
                  "    )",
                  "    var overallHash = await sha3256(overallHashData)",
                  "",
                  "    pm.globals.set(\"hash_of_request_data\", overallHash);",
                  "",
                  "    var mnemonic = pm.variables.get(\"mnemonic\")",
                  "    pm.globals.set(\"signature\", await sign(overallHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"hash\": \"{{hash_of_request_data}}\",\n    \"signature\": \"{{signature}}\",\n    \"version\": \"1.0\",\n    \"client_id\": \"{{wallet_id}}\",\n    \"creation_date\": {{current_timestamp}},\n    \"to_client_id\": \"{{to_wallet_id}}\",\n    \"transaction_data\": \"Message to recipient\",\n    \"transaction_fee\": 0,\n    \"transaction_type\": 0,\n    \"transaction_value\": {{send_amount}},\n    \"public_key\": \"{{public_key}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{test_case_miner}}/v1/transaction/put",
              "host": [
                "{{test_case_miner}}"
              ],
              "path": [
                "v1",
                "transaction",
                "put"
              ]
            }
          },
          "response": []
        },
        {
          "name": "2. Confirm ZCN sent",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"zcn_sent\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"zcn_sent_confirmed\", pm.response.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  ""
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "if(utils.isFlagSet(\"zcn_sent\")){",
                  "    utils.delayTestUntilHttpCodeReceived(pm, 200)",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/transaction/get/confirmation?hash={{send_zcn_txn_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "transaction",
                "get",
                "confirmation"
              ],
              "query": [
                {
                  "key": "hash",
                  "value": "{{send_zcn_txn_id}}",
                  "description": "The read pool that we have requested be created "
                }
              ]
            },
            "description": "Similar to the create allocation and faucet requests, the lock read tokens request must be confirmed by a consensus of sharders before the read pool can be considered created."
          },
          "response": []
        },
        {
          "name": "3. Get Balance",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"zcn_sent_confirmed\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  "",
                  "utils.test.runConditionally(\"zcn_sent_confirmed\", \"Balance matches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.balance).to.eql(pm.variables.get(\"send_amount\"));",
                  "});",
                  "",
                  "utils.test.runConditionally(\"zcn_sent_confirmed\", \"txn matches send txn hash\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.txn).to.eql(pm.variables.get(\"send_zcn_txn_id\"));",
                  "});",
                  "",
                  "utils.test.runConditionally(\"zcn_sent_confirmed\", \"Round present\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.round).to.not.equal(null);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/client/get/balance?client_id={{to_wallet_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "client",
                "get",
                "balance"
              ],
              "query": [
                {
                  "key": "client_id",
                  "value": "{{to_wallet_id}}"
                }
              ]
            },
            "description": "Get wallet balance post-faucet"
          },
          "response": []
        }
      ]
    },
    {
      "name": "Unlock Interest Tokens",
      "item": [
        {
          "name": "1. Wait for locked interest tokens time limit to expire",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"interest_tokens_locked_confirmed\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  "",
                  "utils.test.runConditionally(\"interest_tokens_locked_confirmed\", \"Unlockable read token found\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    var stats = response.stats;",
                  "",
                  "    for(i = 0; i < stats.length; i ++){",
                  "        if(!stats[i].locked){",
                  "            pm.globals.set(\"unlockable_interest_pool_found\", true);",
                  "            pm.globals.set(\"unlockable_interest_pool_id\", stats[i].pool_id);",
                  "            return;",
                  "        }",
                  "    }",
                  "    ",
                  "    pm.expect.fail(\"No unlockable interest tokens found\")",
                  "",
                  "});"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "unlockedTokensFound = function(responseBody){",
                  "    var response = JSON.parse(responseBody.text());",
                  "    var stats = response.stats;",
                  "",
                  "    for(i = 0; i < stats.length; i ++){",
                  "        if(!stats[i].locked){",
                  "            console.info(\"Unlockable interest tokens found. Continung with test...\")",
                  "            return true;",
                  "        }",
                  "    }",
                  "",
                  "    console.warn(\"Unlockable interest tokens NOT found. Delaying test...\")",
                  "    utils.sleep(10000)",
                  "    ",
                  "    return false;",
                  "}",
                  "",
                  "if(utils.isFlagSet(\"interest_tokens_locked_confirmed\")){",
                  "  utils.delayTestUntil(pm, unlockedTokensFound)",
                  "}",
                  ""
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/screst/{{interest_smart_contract_address}}/getPoolsStats?client_id={{wallet_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "screst",
                "{{interest_smart_contract_address}}",
                "getPoolsStats"
              ],
              "query": [
                {
                  "key": "client_id",
                  "value": "{{wallet_id}}"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "2. Unlock interest tokens",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"unlockable_interest_pool_found\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"unlock_interest_token_txn_sent\", responseCode.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"unlock_interest_token_txn\", response.entity.hash);",
                  "});    "
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    // timestamp is in the unix epoch (seconds) format",
                  "    pm.globals.set(\"current_timestamp\", Math.round(Date.now() / 1000));",
                  "",
                  "    // postman boilerplate to retrieve the request body, we need data from here for the hash",
                  "    var requestBody = JSON.parse(Property.replaceSubstitutions(pm.request.body.raw, pm.variables.toObject()))",
                  "    var creationDate = requestBody.creation_date",
                  "    var clientId = requestBody.client_id;",
                  "    var toClientId = requestBody.to_client_id;",
                  "    var transactionValue = requestBody.transaction_value;",
                  "",
                  "    var transactionDataHash = await sha3256(requestBody.transaction_data)",
                  "",
                  "    //if hash data is not available, we insert a blank string rather than hashing one less item",
                  "    var overallHashData = (",
                  "        (creationDate == undefined ? \"\" : creationDate) + \":\" +",
                  "        (clientId == undefined ? \"\" : clientId) + \":\" +",
                  "        (toClientId == undefined ? \"\" : toClientId) + \":\" +",
                  "        (transactionValue == undefined ? \"\" : transactionValue) + \":\" +",
                  "        transactionDataHash",
                  "    )",
                  "    var overallHash = await sha3256(overallHashData)",
                  "",
                  "    pm.globals.set(\"hash_of_request_data\", overallHash);",
                  "",
                  "    var mnemonic = pm.variables.get(\"mnemonic\")",
                  "    pm.globals.set(\"signature\", await sign(overallHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"hash\": \"{{hash_of_request_data}}\",\n    \"signature\": \"{{signature}}\",\n    \"version\": \"1.0\",\n    \"client_id\": \"{{wallet_id}}\",\n    \"creation_date\": {{current_timestamp}},\n    \"to_client_id\": \"{{interest_smart_contract_address}}\",\n    \"transaction_data\": \"{\\\"name\\\":\\\"unlock\\\",\\\"input\\\":{\\\"pool_id\\\":\\\"{{unlockable_interest_pool_id}}\\\"}}\",\n    \"transaction_fee\": 0,\n    \"transaction_type\": 1000,\n    \"transaction_value\": 0,\n    \"public_key\": \"{{public_key}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{test_case_miner}}/v1/transaction/put",
              "host": [
                "{{test_case_miner}}"
              ],
              "path": [
                "v1",
                "transaction",
                "put"
              ]
            }
          },
          "response": []
        },
        {
          "name": "3. Confirm token unlock",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"unlock_interest_token_txn_sent\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  ""
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "if(utils.isFlagSet(\"unlock_interest_token_txn_sent\")){",
                  "    utils.delayTestUntilHttpCodeReceived(pm, 200)",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/transaction/get/confirmation?hash={{unlock_interest_token_txn}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "transaction",
                "get",
                "confirmation"
              ],
              "query": [
                {
                  "key": "hash",
                  "value": "{{unlock_interest_token_txn}}",
                  "description": "The read pool that we have requested be created "
                }
              ]
            },
            "description": "Similar to the create allocation and faucet requests, the lock read tokens request must be confirmed by a consensus of sharders before the read pool can be considered created."
          },
          "response": []
        }
      ]
    },
    {
      "name": "Unlock Read Tokens",
      "item": [
        {
          "name": "1. Wait for locked read tokens time limit to expire",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"read_tokens_locked_confirmed\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  "",
                  "utils.test.runConditionally(\"read_tokens_locked_confirmed\", \"Unlockable read token found\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    var pools = response.pools;",
                  "",
                  "    for(i = 0; i < pools.length; i ++){",
                  "        if(!pools[i].locked){",
                  "            pm.globals.set(\"unlockable_read_pool_found\", true);",
                  "            pm.globals.set(\"unlockable_read_pool_id\", pools[i].id);",
                  "            return;",
                  "        }",
                  "    }",
                  "    ",
                  "    pm.expect.fail(\"No unlockable read tokens found\")",
                  "",
                  "});"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "unlockedTokensFound = function(responseBody){",
                  "    var response = JSON.parse(responseBody.text());",
                  "    var pools = response.pools;",
                  "",
                  "    for(i = 0; i < pools.length; i ++){",
                  "        if(!pools[i].locked){",
                  "            console.info(\"Unlockable read tokens found. Continung with test...\")",
                  "            return true;",
                  "        }",
                  "    }",
                  "",
                  "    console.warn(\"Unlockable read tokens NOT found. Delaying test...\")",
                  "    utils.sleep(10000)",
                  "    ",
                  "    return false;",
                  "}",
                  "",
                  "if(utils.isFlagSet(\"read_tokens_locked_confirmed\")){",
                  "  utils.delayTestUntil(pm, unlockedTokensFound)",
                  "}",
                  ""
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/screst/{{storage_smart_contract_address}}/getReadPoolStat?client_id={{wallet_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "screst",
                "{{storage_smart_contract_address}}",
                "getReadPoolStat"
              ],
              "query": [
                {
                  "key": "client_id",
                  "value": "{{wallet_id}}"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "2. Unlock read tokens",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"unlockable_read_pool_found\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"unlock_read_token_txn_sent\", responseCode.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"unlock_read_token_txn\", response.entity.hash);",
                  "});    "
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    // timestamp is in the unix epoch (seconds) format",
                  "    pm.globals.set(\"current_timestamp\", Math.round(Date.now() / 1000));",
                  "",
                  "    // postman boilerplate to retrieve the request body, we need data from here for the hash",
                  "    var requestBody = JSON.parse(Property.replaceSubstitutions(pm.request.body.raw, pm.variables.toObject()))",
                  "    var creationDate = requestBody.creation_date",
                  "    var clientId = requestBody.client_id;",
                  "    var toClientId = requestBody.to_client_id;",
                  "    var transactionValue = requestBody.transaction_value;",
                  "",
                  "    var transactionDataHash = await sha3256(requestBody.transaction_data)",
                  "",
                  "    //if hash data is not available, we insert a blank string rather than hashing one less item",
                  "    var overallHashData = (",
                  "        (creationDate == undefined ? \"\" : creationDate) + \":\" +",
                  "        (clientId == undefined ? \"\" : clientId) + \":\" +",
                  "        (toClientId == undefined ? \"\" : toClientId) + \":\" +",
                  "        (transactionValue == undefined ? \"\" : transactionValue) + \":\" +",
                  "        transactionDataHash",
                  "    )",
                  "    var overallHash = await sha3256(overallHashData)",
                  "",
                  "    pm.globals.set(\"hash_of_request_data\", overallHash);",
                  "",
                  "    var mnemonic = pm.variables.get(\"mnemonic\")",
                  "    pm.globals.set(\"signature\", await sign(overallHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"hash\": \"{{hash_of_request_data}}\",\n    \"signature\": \"{{signature}}\",\n    \"version\": \"1.0\",\n    \"client_id\": \"{{wallet_id}}\",\n    \"creation_date\": {{current_timestamp}},\n    \"to_client_id\": \"{{storage_smart_contract_address}}\",\n    \"transaction_data\": \"{\\\"name\\\":\\\"read_pool_unlock\\\",\\\"input\\\":{\\\"pool_id\\\":\\\"{{unlockable_read_pool_id}}\\\"}}\",\n    \"transaction_fee\": 0,\n    \"transaction_type\": 1000,\n    \"transaction_value\": 0,\n    \"public_key\": \"{{public_key}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{test_case_miner}}/v1/transaction/put",
              "host": [
                "{{test_case_miner}}"
              ],
              "path": [
                "v1",
                "transaction",
                "put"
              ]
            }
          },
          "response": []
        },
        {
          "name": "3. Confirm token unlock",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"unlock_read_token_txn_sent\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  ""
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "if(utils.isFlagSet(\"unlock_read_token_txn_sent\")){",
                  "    utils.delayTestUntilHttpCodeReceived(pm, 200)",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/transaction/get/confirmation?hash={{unlock_read_token_txn}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "transaction",
                "get",
                "confirmation"
              ],
              "query": [
                {
                  "key": "hash",
                  "value": "{{unlock_read_token_txn}}",
                  "description": "The read pool that we have requested be created "
                }
              ]
            },
            "description": "Similar to the create allocation and faucet requests, the lock read tokens request must be confirmed by a consensus of sharders before the read pool can be considered created."
          },
          "response": []
        }
      ]
    },
    {
      "name": "Unlock Write Tokens",
      "item": [
        {
          "name": "1. Wait for locked write tokens time limit to expire",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"write_tokens_locked_confirmed\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  "",
                  "utils.test.runConditionally(\"write_tokens_locked_confirmed\", \"Unlockable write token found\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    var pools = response.pools;",
                  "",
                  "    for(i = 0; i < pools.length; i ++){",
                  "        if(!pools[i].locked){",
                  "            pm.globals.set(\"unlockable_write_pool_found\", true);",
                  "            pm.globals.set(\"unlockable_write_pool_id\", pools[i].id);",
                  "            return;",
                  "        }",
                  "    }",
                  "    ",
                  "    pm.expect.fail(\"No unlockable write tokens found\")",
                  "",
                  "});"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "unlockedTokensFound = function(responseBody){",
                  "    var response = JSON.parse(responseBody.text());",
                  "    var pools = response.pools;",
                  "",
                  "    for(i = 0; i < pools.length; i ++){",
                  "        if(!pools[i].locked){",
                  "            console.info(\"Unlockable write tokens found. Continung with test...\")",
                  "            return true;",
                  "        }",
                  "    }",
                  "",
                  "    console.warn(\"Unlockable write tokens NOT found. Delaying test...\")",
                  "    utils.sleep(10000)",
                  "    ",
                  "    return false;",
                  "}",
                  "",
                  "if(utils.isFlagSet(\"write_tokens_locked_confirmed\")){",
                  "    utils.delayTestUntil(pm, unlockedTokensFound)",
                  "}",
                  ""
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/screst/{{storage_smart_contract_address}}/getWritePoolStat?client_id={{wallet_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "screst",
                "{{storage_smart_contract_address}}",
                "getWritePoolStat"
              ],
              "query": [
                {
                  "key": "client_id",
                  "value": "{{wallet_id}}"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "2. Unlock write tokens",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"unlockable_write_pool_found\", \"Response code is 200\", function () {",
                  "    pm.globals.set(\"unlock_write_token_txn_sent\", responseCode.code == 200);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"unlock_write_token_txn\", response.entity.hash);",
                  "});    "
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    // timestamp is in the unix epoch (seconds) format",
                  "    pm.globals.set(\"current_timestamp\", Math.round(Date.now() / 1000));",
                  "",
                  "    // postman boilerplate to retrieve the request body, we need data from here for the hash",
                  "    var requestBody = JSON.parse(Property.replaceSubstitutions(pm.request.body.raw, pm.variables.toObject()))",
                  "    var creationDate = requestBody.creation_date",
                  "    var clientId = requestBody.client_id;",
                  "    var toClientId = requestBody.to_client_id;",
                  "    var transactionValue = requestBody.transaction_value;",
                  "",
                  "    var transactionDataHash = await sha3256(requestBody.transaction_data)",
                  "",
                  "    //if hash data is not available, we insert a blank string rather than hashing one less item",
                  "    var overallHashData = (",
                  "        (creationDate == undefined ? \"\" : creationDate) + \":\" +",
                  "        (clientId == undefined ? \"\" : clientId) + \":\" +",
                  "        (toClientId == undefined ? \"\" : toClientId) + \":\" +",
                  "        (transactionValue == undefined ? \"\" : transactionValue) + \":\" +",
                  "        transactionDataHash",
                  "    )",
                  "    var overallHash = await sha3256(overallHashData)",
                  "",
                  "    pm.globals.set(\"hash_of_request_data\", overallHash);",
                  "",
                  "    var mnemonic = pm.variables.get(\"mnemonic\")",
                  "    pm.globals.set(\"signature\", await sign(overallHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"hash\": \"{{hash_of_request_data}}\",\n    \"signature\": \"{{signature}}\",\n    \"version\": \"1.0\",\n    \"client_id\": \"{{wallet_id}}\",\n    \"creation_date\": {{current_timestamp}},\n    \"to_client_id\": \"{{storage_smart_contract_address}}\",\n    \"transaction_data\": \"{\\\"name\\\":\\\"write_pool_unlock\\\",\\\"input\\\":{\\\"pool_id\\\":\\\"{{unlockable_write_pool_id}}\\\"}}\",\n    \"transaction_fee\": 0,\n    \"transaction_type\": 1000,\n    \"transaction_value\": 0,\n    \"public_key\": \"{{public_key}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{test_case_miner}}/v1/transaction/put",
              "host": [
                "{{test_case_miner}}"
              ],
              "path": [
                "v1",
                "transaction",
                "put"
              ]
            }
          },
          "response": []
        },
        {
          "name": "3. Confirm token unlock",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "utils.test.runConditionally(\"unlock_write_token_txn_sent\", \"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  ""
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "if(utils.isFlagSet(\"unlock_write_token_txn_sent\")){",
                  "    utils.delayTestUntilHttpCodeReceived(pm, 200)",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/transaction/get/confirmation?hash={{unlock_write_token_txn}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "transaction",
                "get",
                "confirmation"
              ],
              "query": [
                {
                  "key": "hash",
                  "value": "{{unlock_write_token_txn}}",
                  "description": "The read pool that we have requested be created "
                }
              ]
            },
            "description": "Similar to the create allocation and faucet requests, the lock read tokens request must be confirmed by a consensus of sharders before the read pool can be considered created."
          },
          "response": []
        }
      ]
    },
    {
      "name": "Regressions Teardown",
      "item": [
        {
          "name": "1. Remove temporary variables",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "async function main(){",
                  " const interval = setTimeout(() => {}, 10000);",
                  "const whitelist = [",
                  "    \"test_case_miner\",",
                  "    \"test_case_sharder\",",
                  "    \"public_key\",",
                  "    \"wallet_id\",",
                  "    \"allocation_id\",",
                  "    \"collaborator_wallet_id\",",
                  "    \"collaborator_mnemonic\",",
                  "    \"skip_teardown\",",
                  "    \"force_run_tests\"",
                  "];",
                  "",
                  "var variables = pm.globals.values.members",
                  "",
                  "",
                  "variables.each((variable) => {",
                  "   ",
                  "    if(variable != undefined){",
                  "        var variableName = String(variable.key)",
                  "        if(!whitelist.includes(variableName)){",
                  "            pm.globals.unset(variableName)",
                  "            console.log(\"Deleted temp variable [\" + variableName + \"] with value [\" + variable.value + \"]\")",
                  "        }",
                  "    }",
                  "    ",
                  "})",
                  "",
                  "variables = pm.globals.values.members",
                  "variables.each((variable) => {",
                  "   ",
                  "    if(variable != undefined){",
                  "        var variableName = String(variable.key)",
                  "        if(!whitelist.includes(variableName)){",
                  "            pm.globals.unset(variableName)",
                  "            console.log(\"Deleted temp variable [\" + variableName + \"] with value [\" + variable.value + \"]\")",
                  "        }",
                  "    }",
                  "    ",
                  "})",
                  "",
                  "clearTimeout(interval)",
                  "",
                  "}",
                  "",
                  "if(utils.isFlagUnset(\"skip_teardown\")){",
                  "    main()",
                  "    main()",
                  "    main()",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "HEAD",
            "header": [],
            "url": {
              "raw": "https://{{network}}/dns/network?m=\"Postman requires this URL to be present in order to run the pre-request script, we don't care about the response\"",
              "protocol": "https",
              "host": [
                "{{network}}"
              ],
              "path": [
                "dns",
                "network"
              ],
              "query": [
                {
                  "key": "m",
                  "value": "\"Postman requires this URL to be present in order to run the pre-request script, we don't care about the response\""
                }
              ]
            },
            "description": "Remove temporary variables created as part of the test suite. This makes reading the report page easier, but the values of the variables before deletion are logged below.  \n\nThe request URL is a dummy and can be ignored"
          },
          "response": []
        }
      ]
    }
  ],
  "event": [
    {
      "listen": "prerequest",
      "script": {
        "type": "text/javascript",
        "exec": [
          "utils = {",
          "    delayTestUntilHttpCodeReceived: async function(pm, expectedResponse) {",
          "        const startTime = new Date().getTime()",
          "        console.log(\"Polling API for expected HTTP [\" + expectedResponse + \"] response before postman calls it and test cases execute...\")",
          "        var Property = require('postman-collection').Property;",
          "        var uri = Property.replaceSubstitutions(pm.request.url.toString(), pm.variables.toObject());",
          "        await attemptRequest(uri, expectedResponse)",
          "",
          "        async function attemptRequest(uri, expectedResponse, attempt = 1) {",
          "            const MAX_ATTEMPTS = 10;",
          "            if (attempt > MAX_ATTEMPTS) {",
          "                console.error(\"All polling attempts have been exhaused before an HTTP [\" + expectedResponse + \"] was received. Postman will now call the endpoint and therefore tests may fail.\")",
          "            } else {",
          "                pm.sendRequest(uri, async function(err, response) {",
          "                    if (err != null && response.code == null) {",
          "                        console.warn(\"[\" + attempt + \"/\" + MAX_ATTEMPTS + \"] - Received an error [\" + err.code + \"] rather than the expected HTTP [\" + expectedResponse + \"]\")",
          "                        utils.sleep(1000)",
          "                        await attemptRequest(uri, expectedResponse, ++attempt)",
          "                    } else if (response.code != expectedResponse) {",
          "                        console.warn(\"[\" + attempt + \"/\" + MAX_ATTEMPTS + \"] - Received an HTTP [\" + response.code + \"] rather than the expected [\" + expectedResponse + \"]\")",
          "                        utils.sleep(1000)",
          "                        await attemptRequest(uri, expectedResponse, ++attempt)",
          "                    } else {",
          "                        const elapsedTime = new Date().getTime() - startTime",
          "                        console.info(\"[\" + attempt + \"/\" + MAX_ATTEMPTS + \"] - Received an HTTP [\" + response.code + \"] as expected after [\" + elapsedTime + \"]ms\")",
          "                    }",
          "                });",
          "            }",
          "        }",
          "    },",
          "    delayTestUntil: async function(pm, shouldRetry) {",
          "        const startTime = new Date().getTime()",
          "        console.log(\"Polling API for expected response before postman calls it and test cases execute...\")",
          "        var Property = require('postman-collection').Property;",
          "        var uri = Property.replaceSubstitutions(pm.request.url.toString(), pm.variables.toObject());",
          "        await attemptRequest(uri, shouldRetry)",
          "",
          "        async function attemptRequest(uri, expectedResponse, attempt = 1) {",
          "            const MAX_ATTEMPTS = 10;",
          "            if (attempt > MAX_ATTEMPTS) {",
          "                console.error(\"All polling attempts have been exhaused before expected response was received. Postman will now call the endpoint and therefore tests may fail.\")",
          "            } else {",
          "                pm.sendRequest(uri, async function(err, response) {",
          "                    if (expectedResponse(response)) {",
          "                        const elapsedTime = new Date().getTime() - startTime",
          "                        console.info(\"[\" + attempt + \"/\" + MAX_ATTEMPTS + \"] - Received expected response after [\" + elapsedTime + \"]ms\")",
          "                    } else {",
          "                         console.warn(\"[\" + attempt + \"/\" + MAX_ATTEMPTS + \"] - Response did not match expected\")",
          "                        utils.sleep(1000)",
          "                        await attemptRequest(uri, expectedResponse, ++attempt)",
          "                    }",
          "                });",
          "            }",
          "        }",
          "    },",
          "    sleep: function(millis) {",
          "        var waitUntil = new Date().getTime() + millis;",
          "        while (new Date().getTime() < waitUntil) {}",
          "    },",
          "    isFlagSet: function(flagName){",
          "        var isSet = (String(pm.variables.get(flagName)).toLowerCase()  == \"true\")",
          "        var forceRunTests = (String(pm.variables.get(\"force_run_tests\")).toLowerCase()  == \"true\")",
          "",
          "        if(forceRunTests){",
          "            console.info(\"Flag [\" + flagName + \"] status will be ignored as forceRunTests is true\")",
          "        } else if(!isSet){",
          "            console.warn(\"Flag [\" + flagName + \"] was NOT set\")",
          "        } else {",
          "            console.info(\"Flag [\" + flagName + \"] was set\")",
          "        }",
          "",
          "        return forceRunTests|| isSet",
          "    },",
          "",
          "    isFlagUnset: function(flagName){",
          "        var isSet = (String(pm.variables.get(flagName)).toLowerCase()  == \"true\")",
          "",
          "",
          "        if(!isSet){",
          "            console.info(\"Flag [\" + flagName + \"] was not set\")",
          "        } else {",
          "            console.warn(\"Flag [\" + flagName + \"] WAS set\")",
          "        }",
          "",
          "        return !isSet",
          "    }",
          "}"
        ]
      }
    },
    {
      "listen": "test",
      "script": {
        "type": "text/javascript",
        "exec": [
          "utils = {",
          "    test : {",
          "        runConditionally: function (runCondition, testName, test){",
          "",
          "           var runConditionValue = (typeof runCondition === \"boolean\") ? runCondition : (String(pm.variables.get(runCondition)).toLowerCase()  == \"true\")",
          "",
          "           var forceRunTests = (String(pm.variables.get(\"force_run_tests\")).toLowerCase()  == \"true\")",
          "        ",
          "            if(forceRunTests || runConditionValue){",
          "                pm.test(testName, test)",
          "            } else {",
          "                pm.test.skip(testName + \" - skipped as test setup condition [\" + runCondition + \"] failed\")",
          "            }",
          "        }",
          "    }",
          "}"
        ]
      }
    }
  ],
  "variable": [
    {
      "key": "upload-metadata",
      "value": "{ \"filename\": \"{{filename}}\", \"filepath\": \"{{remote_filepath}}\", \"actual_hash\": \"{{fileHash}}\", \"actual_size\": {{fileSize}}, \"connection_id\": \"{{connection_id_for_current_blobber}}\" }"
    },
    {
      "key": "upload-request",
      "value": "--Xform_data_boundary_exampleX\nContent-Disposition: form-data; name=\"uploadFile\"; filename=\"{{filename}}\"\n\n{{current_ec_shard}}\n--Xform_data_boundary_exampleX\nContent-Disposition: form-data; name=\"connection_id\"\n\n{{connection_id_for_current_blobber}}\n--Xform_data_boundary_exampleX\nContent-Disposition: form-data; name=\"{{upload-operation}}Meta\"\n\n{{upload-metadata}}\n--Xform_data_boundary_exampleX--"
    }
  ]
}